<!DOCTYPE html>
<html lang="ja">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Toy Derby: Grand Prix</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.tailwindcss.com"></script>
    <link
        href="https://fonts.googleapis.com/css2?family=Chakra+Petch:wght@400;600;700&family=Orbitron:wght@500;700;900&family=Zen+Kaku+Gothic+New:wght@500;700;900&display=swap"
        rel="stylesheet">
    <script>
        tailwind.config = {
            theme: {
                extend: {
                    fontFamily: {
                        sans: ['"Zen Kaku Gothic New"', 'sans-serif'],
                        display: ['"Orbitron"', 'sans-serif'],
                        tech: ['"Chakra Petch"', 'sans-serif'],
                    },
                    colors: {
                        gold: { 400: '#FBBF24', 500: '#F59E0B', 600: '#D97706', glow: '#FFD700' },
                        glass: {
                            light: 'rgba(255, 255, 255, 0.1)',
                            dark: 'rgba(0, 0, 0, 0.6)',
                            border: 'rgba(255, 255, 255, 0.2)'
                        }
                    }
                }
            }
        }
    </script>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background-color: #1a1a2e;
            font-family: 'Zen Kaku Gothic New', sans-serif;
            color: #e2e8f0;
        }

        /* Glassmorphism Utilities */
        .glass-panel {
            background: rgba(15, 23, 42, 0.65);
            backdrop-filter: blur(12px);
            -webkit-backdrop-filter: blur(12px);
            border: 1px solid rgba(255, 255, 255, 0.1);
            box-shadow: 0 8px 32px 0 rgba(0, 0, 0, 0.37);
        }

        .glass-header {
            background: linear-gradient(180deg, rgba(0, 0, 0, 0.8) 0%, rgba(0, 0, 0, 0) 100%);
            padding-bottom: 2rem;
        }

        /* Premium Horse Card */
        .horse-card {
            background: linear-gradient(145deg, rgba(30, 41, 59, 0.9), rgba(15, 23, 42, 0.95));
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: 12px;
            box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.5);
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            position: relative;
            overflow: hidden;
        }

        .horse-card::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: linear-gradient(45deg, transparent 40%, rgba(255, 255, 255, 0.05) 45%, transparent 50%);
            z-index: 1;
            transform: translateX(-100%);
            transition: transform 0.6s;
        }

        .horse-card:hover::before {
            transform: translateX(100%);
        }

        .horse-card:hover {
            transform: translateY(-5px) scale(1.02);
            border-color: rgba(251, 191, 36, 0.5);
            box-shadow: 0 10px 25px -5px rgba(251, 191, 36, 0.15);
        }

        .horse-card.selected {
            border: 2px solid #F59E0B;
            background: linear-gradient(145deg, rgba(50, 40, 20, 0.95), rgba(30, 25, 10, 0.95));
            box-shadow: 0 0 20px rgba(245, 158, 11, 0.4);
            transform: scale(1.05);
            z-index: 10;
        }

        .horse-badge {
            position: absolute;
            top: 0;
            right: 0;
            background: linear-gradient(135deg, #F59E0B, #D97706);
            color: #fff;
            font-family: 'Orbitron', sans-serif;
            font-weight: 700;
            font-size: 0.8rem;
            padding: 4px 8px;
            border-bottom-left-radius: 8px;
            box-shadow: -2px 2px 5px rgba(0, 0, 0, 0.3);
            z-index: 5;
        }

        .skill-badge {
            position: absolute;
            bottom: 0;
            left: 0;
            right: 0;
            background: rgba(0, 0, 0, 0.8);
            border-top: 1px solid rgba(255, 255, 255, 0.1);
            color: #94a3b8;
            font-family: 'Chakra Petch', sans-serif;
            font-size: 0.65rem;
            text-align: center;
            padding: 4px;
            text-transform: uppercase;
            letter-spacing: 0.05em;
        }

        .horse-card.selected .skill-badge {
            color: #FCD34D;
            background: rgba(40, 20, 0, 0.8);
        }

        /* Neon Button */
        .btn-neon {
            background: linear-gradient(90deg, #F59E0B, #ea580c);
            color: white;
            text-shadow: 0 2px 4px rgba(0, 0, 0, 0.3);
            position: relative;
            overflow: hidden;
            transition: all 0.3s;
            font-family: 'Orbitron', sans-serif;
            letter-spacing: 0.05em;
            border: 1px solid rgba(255, 255, 255, 0.2);
        }

        .btn-neon:hover:not(:disabled) {
            transform: translateY(-2px);
            box-shadow: 0 0 20px rgba(245, 158, 11, 0.6);
            filter: brightness(1.2);
        }

        .btn-neon:active:not(:disabled) {
            transform: translateY(1px);
        }

        .btn-neon:disabled {
            background: #334155;
            color: #94a3b8;
            cursor: not-allowed;
            border-color: transparent;
        }

        /* Game UI Layout */
        #game-ui {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            display: flex;
            flex-direction: column;
            justify-content: space-between;
            overflow: hidden;
        }

        .interactive {
            pointer-events: auto;
        }

        #betting-panel {
            background: transparent;
        }

        /* Loader */
        #loader {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: #0f172a;
            color: white;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 50;
            transition: opacity 0.5s;
        }

        .loading-bar {
            width: 240px;
            height: 6px;
            background: #1e293b;
            margin-top: 15px;
            border-radius: 3px;
            overflow: hidden;
            box-shadow: inset 0 1px 3px rgba(0, 0, 0, 0.5);
        }

        .loading-progress {
            height: 100%;
            background: linear-gradient(90deg, #F59E0B, #FCD34D);
            width: 0%;
            transition: width 0.2s;
            box-shadow: 0 0 10px rgba(245, 158, 11, 0.5);
        }

        /* Rank Panel */
        #rank-panel ul li {
            font-family: 'Chakra Petch', sans-serif;
            transition: all 0.2s;
        }

        /* Cut-in */
        #cut-in-overlay {
            position: absolute;
            top: 25%;
            left: -100%;
            width: 100%;
            height: 240px;
            display: flex;
            align-items: center;
            background: linear-gradient(90deg, rgba(0, 0, 0, 0) 0%, rgba(245, 158, 11, 0.8) 15%, rgba(234, 88, 12, 0.9) 50%, rgba(245, 158, 11, 0.8) 85%, rgba(0, 0, 0, 0) 100%);
            z-index: 40;
            transform: skewX(-15deg);
            transition: left 0.4s cubic-bezier(0.2, 0.8, 0.2, 1);
            pointer-events: none;
            opacity: 0;
            backdrop-filter: blur(4px);
            border-top: 2px solid rgba(255, 255, 255, 0.4);
            border-bottom: 2px solid rgba(255, 255, 255, 0.4);
        }

        #cut-in-overlay.active {
            left: -10%;
            opacity: 1;
        }

        .cut-in-content {
            transform: skewX(15deg);
            display: flex;
            align-items: center;
            width: 100%;
            justify-content: center;
            color: white;
            text-shadow: 4px 4px 0 rgba(0, 0, 0, 0.5);
        }

        .cut-in-text {
            font-family: 'Orbitron', sans-serif;
            font-size: 3.5rem;
            font-weight: 900;
            font-style: italic;
            margin-left: 30px;
            text-transform: uppercase;
            background: linear-gradient(to bottom, #fff, #FCD34D);
            -webkit-background-clip: text;
            background-clip: text;
            -webkit-text-fill-color: transparent;
            filter: drop-shadow(0 4px 4px rgba(0, 0, 0, 0.5));
        }

        .cut-in-horse-name {
            font-size: 1.5rem;
            margin-bottom: -10px;
            opacity: 0.95;
            letter-spacing: 0.1em;
        }

        /* Commentary Box */
        #commentary-box {
            position: absolute;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%) translateY(100px);
            width: 90%;
            max-width: 800px;
            background: linear-gradient(to right, rgba(0, 0, 0, 0), rgba(0, 0, 0, 0.8) 20%, rgba(0, 0, 0, 0.8) 80%, rgba(0, 0, 0, 0));
            padding: 1rem 3rem;
            border-radius: 0;
            text-align: center;
            color: #4ade80;
            /* Neon Green */
            font-family: 'Zen Kaku Gothic New', sans-serif;
            font-weight: 700;
            font-size: 1.4rem;
            opacity: 0;
            transition: all 0.3s;
            text-shadow: 0 0 10px rgba(74, 222, 128, 0.5);
            pointer-events: none;
            border-top: 1px solid rgba(74, 222, 128, 0.3);
            border-bottom: 1px solid rgba(74, 222, 128, 0.3);
        }

        #commentary-box.active {
            opacity: 1;
            transform: translateX(-50%) translateY(0);
        }

        /* Countdown */
        .scale-in {
            animation: scaleIn 0.4s cubic-bezier(0.175, 0.885, 0.32, 1.275);
        }

        @keyframes scaleIn {
            0% {
                transform: scale(0);
                opacity: 0;
            }

            60% {
                transform: scale(1.2);
            }

            100% {
                transform: scale(1);
                opacity: 1;
            }
        }

        .speed-lines {
            position: absolute;
            inset: 0;
            background: repeating-linear-gradient(90deg, transparent 0, transparent 20px, rgba(255, 255, 255, 0.2) 21px, transparent 22px);
            animation: speedLines 0.1s linear infinite;
            pointer-events: none;
            opacity: 0;
            transition: opacity 0.3s;
        }

        .speed-lines.active {
            opacity: 0.3;
        }

        @keyframes speedLines {
            from {
                transform: translateX(0);
            }

            to {
                transform: translateX(-20px);
            }
        }

        /* Countdown */
        #countdown-text {
            text-shadow: 4px 4px 0px #000, 0 0 20px rgba(255, 255, 0, 0.5);
            transition: opacity 0.5s;
        }

        .scale-in {
            animation: scaleIn 0.5s cubic-bezier(0.175, 0.885, 0.32, 1.275) forwards;
        }

        @keyframes scaleIn {
            0% {
                transform: scale(0);
                opacity: 0;
            }

            80% {
                transform: scale(1.2);
                opacity: 1;
            }

            100% {
                transform: scale(1.0);
                opacity: 1;
            }
        }

        /* Rank Panel */
        #rank-panel {
            transition: opacity 0.3s;
        }

        .rank-row {
            transition: top 0.3s ease-out;
        }

        /* Commentary Box */
        #commentary-box {
            position: absolute;
            bottom: 120px;
            left: 50%;
            transform: translateX(-50%);
            width: 90%;
            max-width: 600px;
            background: rgba(0, 0, 0, 0.7);
            border: 2px solid rgba(255, 255, 255, 0.3);
            border-radius: 8px;
            padding: 10px 20px;
            color: white;
            text-align: center;
            font-weight: bold;
            font-size: 1.1rem;
            text-shadow: 1px 1px 2px black;
            opacity: 0;
            transition: opacity 0.5s;
            z-index: 30;
            pointer-events: none;
        }

        #commentary-box.active {
            opacity: 1;
        }

        .commentary-label {
            display: inline-block;
            background: #D32F2F;
            color: white;
            padding: 2px 8px;
            font-size: 0.7rem;
            border-radius: 4px;
            margin-right: 8px;
            vertical-align: middle;
        }

        #sound-toggle {
            position: absolute;
            top: 80px;
            right: 20px;
            background: rgba(0, 0, 0, 0.5);
            color: white;
            padding: 8px;
            border-radius: 50%;
            width: 40px;
            height: 40px;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            pointer-events: auto;
            z-index: 60;
        }
    </style>
</head>

<body>

    <!-- Loading Screen -->
    <div id="loader">
        <div class="text-3xl font-bold mb-2">Toy Derby GP</div>
        <div class="text-sm text-gray-400">Building Racecourse...</div>
        <div class="loading-bar">
            <div class="loading-progress" id="progress-bar"></div>
        </div>
    </div>

    <!-- UI Overlay -->
    <div id="game-ui">
        <!-- Sound Toggle -->
        <div id="sound-toggle" onclick="toggleMute()">üîä</div>

        <!-- Countdown Overlay -->
        <div id="countdown-overlay"
            class="absolute inset-0 flex items-center justify-center z-50 pointer-events-none hidden">
            <div id="countdown-text" class="text-9xl font-black text-yellow-400 italic">3</div>
        </div>

        <!-- Rank Panel (Top Right) -->
        <div id="rank-panel"
            class="hidden absolute top-20 right-4 bg-black/60 backdrop-blur-md p-3 rounded-xl text-white w-56 z-20 border border-white/10 shadow-xl">
            <div class="flex justify-between items-center mb-2 border-b border-white/20 pb-1">
                <h3 class="text-xs font-bold text-gray-300 uppercase tracking-wider">Live Ranking</h3>
                <div class="w-2 h-2 rounded-full bg-red-500 animate-pulse"></div>
            </div>
            <ul id="rank-list" class="space-y-1"></ul>
        </div>

        <!-- Commentary Box -->
        <div id="commentary-box">
            <span class="commentary-label">LIVE</span>
            <span id="commentary-text">„É¨„Éº„ÇπÈñãÂßã„ÇíÂæÖ„Å£„Å¶„ÅÑ„Åæ„Åô...</span>
        </div>

        <!-- Cut-in Overlay -->
        <div id="cut-in-overlay">
            <div class="speed-lines"></div>
            <div class="cut-in-content">
                <div id="cut-in-horse" class="text-6xl">üê¥</div>
                <div class="flex flex-col">
                    <span id="cut-in-name" class="cut-in-horse-name">Horse Name</span>
                    <span id="cut-in-skill" class="cut-in-text">SKILL NAME!</span>
                </div>
            </div>
        </div>

        <!-- Header -->
        <div class="p-6 flex justify-between items-start glass-header w-full absolute top-0 z-10 pointer-events-none">
            <div class="glass-panel px-6 py-3 rounded-lg flex items-center gap-4 transform skew-x-[-10deg]">
                <h1 class="text-2xl font-tech font-bold text-white italic tracking-wider skew-x-[10deg]">
                    TOY DERBY <span class="text-gold-500 text-sm">GP</span>
                </h1>
                <div class="h-6 w-px bg-white/20 skew-x-[10deg]"></div>
                <div class="flex items-center gap-2 skew-x-[10deg]">
                    <div class="text-gold-400 text-xs">CREDITS</div>
                    <span id="wallet-display"
                        class="font-display font-bold text-gold-glow text-2xl tracking-widest text-shadow-glow">1000</span>
                    <span class="text-xs text-gray-400">G</span>
                </div>
            </div>

            <button id="camera-btn"
                class="interactive hidden btn-neon rounded-lg w-12 h-12 flex items-center justify-center text-xl shadow-lg"
                onclick="toggleCamera()">
                ÔøΩ
            </button>
        </div>

        <!-- Speed Lines Overlay -->
        <div id="speed-lines" class="speed-lines"></div>

        <!-- Center: Results -->
        <div id="center-panel" class="absolute inset-0 flex items-center justify-center pointer-events-none z-30">
            <div id="result-modal"
                class="hidden interactive glass-panel border border-gold-500/30 p-8 rounded-xl shadow-xl max-w-sm w-full text-center transform scale-95 opacity-0 transition-all duration-300">
                <div class="text-6xl mb-4 filter drop-shadow-[0_0_10px_rgba(255,255,255,0.5)]">üèÅ</div>
                <h2 class="text-4xl font-display font-bold mb-2 text-white italic tracking-tighter">FINISH!</h2>
                <div id="result-message" class="text-lg mb-6 font-tech text-gray-300 tracking-wide">...</div>

                <div class="bg-black/40 rounded-lg p-4 mb-8 border border-white/5">
                    <div class="text-xs text-gray-500 uppercase font-bold tracking-widest mb-1">TOTAL PAYOUT</div>
                    <div id="payout-display" class="text-5xl font-display font-bold text-gold-glow drop-shadow-md">0 G
                    </div>
                </div>

                <button onclick="resetGame()"
                    class="w-full btn-neon py-4 text-xl font-bold rounded shadow-lg transition transform hover:scale-[1.02] tracking-wider">
                    NEXT RACE
                </button>
            </div>
        </div>

        <!-- Footer: Betting -->
        <div id="betting-panel"
            class="interactive absolute inset-0 flex items-center justify-center z-20 transition-all duration-500 ease-in-out bg-black/50 backdrop-blur-sm">
            <div
                class="glass-panel p-8 rounded-xl shadow-2xl max-w-6xl w-full mx-4 transform transition-all duration-500">
                <div class="flex justify-between items-center mb-6 border-b border-white/10 pb-4">
                    <h3 class="text-white font-tech font-bold text-3xl tracking-widest border-l-4 border-gold-500 pl-4">
                        SELECT HORSE</h3>
                    <div
                        class="bg-black/40 px-6 py-2 rounded-lg text-sm text-gray-300 font-tech flex items-center gap-3 border border-white/5">
                        <span>BET AMOUNT</span>
                        <span class="font-display font-bold text-gold-400 text-2xl">100 G</span>
                    </div>
                </div>

                <div class="grid grid-cols-5 gap-4" id="horse-selector">
                    <!-- Cards generated by JS -->
                </div>

                <div class="mt-8 flex justify-center">
                    <button id="start-btn" onclick="startRace()" disabled
                        class="btn-neon py-4 px-24 text-2xl font-bold rounded skew-x-[-15deg] shadow-[0_0_30px_rgba(245,158,11,0.3)] opacity-50 cursor-not-allowed transition-all hover:scale-105 active:scale-95">
                        <span class="block skew-x-[15deg] tracking-[0.2em]">START RACE</span>
                    </button>
                </div>
            </div>
        </div>
    </div>

    <script>
        // --- Sound Manager (Web Audio API) ---
        const SoundManager = {
            ctx: null,
            isMuted: false,

            init: function () {
                if (!this.ctx) {
                    const AudioContext = window.AudioContext || window.webkitAudioContext;
                    this.ctx = new AudioContext();
                }
                if (this.ctx.state === 'suspended') {
                    this.ctx.resume();
                }
            },

            playOscillator: function (type, freq, duration, startTime = 0, vol = 0.1) {
                if (!this.ctx || this.isMuted) return;
                const osc = this.ctx.createOscillator();
                const gain = this.ctx.createGain();
                osc.type = type;
                osc.frequency.setValueAtTime(freq, this.ctx.currentTime + startTime);
                gain.gain.setValueAtTime(vol, this.ctx.currentTime + startTime);
                gain.gain.exponentialRampToValueAtTime(0.01, this.ctx.currentTime + startTime + duration);
                osc.connect(gain);
                gain.connect(this.ctx.destination);
                osc.start(this.ctx.currentTime + startTime);
                osc.stop(this.ctx.currentTime + startTime + duration);
            },

            playClick: function () {
                this.playOscillator('sine', 800, 0.1, 0, 0.1);
            },

            playCountdown: function (count) {
                if (count > 0) {
                    this.playOscillator('square', 600, 0.15, 0, 0.1); // 3, 2, 1
                } else {
                    this.playOscillator('square', 1200, 0.4, 0, 0.1); // GO!
                }
            },

            playGate: function () {
                if (!this.ctx || this.isMuted) return;
                // Burst of noise
                const bufferSize = this.ctx.sampleRate * 0.5;
                const buffer = this.ctx.createBuffer(1, bufferSize, this.ctx.sampleRate);
                const data = buffer.getChannelData(0);
                for (let i = 0; i < bufferSize; i++) {
                    data[i] = Math.random() * 2 - 1;
                }
                const noise = this.ctx.createBufferSource();
                noise.buffer = buffer;
                const gain = this.ctx.createGain();

                // Lowpass filter for "heavy" gate sound
                const filter = this.ctx.createBiquadFilter();
                filter.type = 'lowpass';
                filter.frequency.value = 500;

                gain.gain.setValueAtTime(0.3, this.ctx.currentTime);
                gain.gain.exponentialRampToValueAtTime(0.01, this.ctx.currentTime + 0.3);

                noise.connect(filter);
                filter.connect(gain);
                gain.connect(this.ctx.destination);
                noise.start();
            },

            playFanfare: function () {
                if (!this.ctx || this.isMuted) return;
                // Simple Arpeggio: C, E, G, C
                const now = this.ctx.currentTime;
                const notes = [523.25, 659.25, 783.99, 1046.50];
                notes.forEach((freq, i) => {
                    this.playOscillator('triangle', freq, 0.3, i * 0.15, 0.15);
                });
                this.playOscillator('triangle', 1046.50, 0.8, 0.6, 0.15);
            },

            playSkill: function () {
                if (!this.ctx || this.isMuted) return;
                const osc = this.ctx.createOscillator();
                const gain = this.ctx.createGain();
                osc.frequency.setValueAtTime(400, this.ctx.currentTime);
                osc.frequency.linearRampToValueAtTime(1200, this.ctx.currentTime + 0.5);
                gain.gain.setValueAtTime(0.1, this.ctx.currentTime);
                gain.gain.linearRampToValueAtTime(0, this.ctx.currentTime + 0.5);
                osc.connect(gain);
                gain.connect(this.ctx.destination);
                osc.start();
                osc.stop(this.ctx.currentTime + 0.5);
            },

            playWin: function () {
                if (!this.ctx || this.isMuted) return;
                // Major chord
                const now = this.ctx.currentTime;
                [523.25, 659.25, 783.99].forEach(f => {
                    const osc = this.ctx.createOscillator();
                    const gain = this.ctx.createGain();
                    osc.type = 'triangle';
                    osc.frequency.value = f;
                    gain.gain.setValueAtTime(0.1, now);
                    gain.gain.exponentialRampToValueAtTime(0.01, now + 1.0);
                    osc.connect(gain); gain.connect(this.ctx.destination);
                    osc.start(now); osc.stop(now + 1.0);
                });
            },

            // Background noise loop (Crowd/Gallop mix)
            noiseNode: null,
            lastOut: 0,
            playAtmosphere: function (active) {
                if (!this.ctx || this.isMuted) return;
                if (active) {
                    if (this.noiseNode) return; // already playing
                    // Pink noise ish
                    const bufferSize = this.ctx.sampleRate * 2;
                    const buffer = this.ctx.createBuffer(1, bufferSize, this.ctx.sampleRate);
                    const data = buffer.getChannelData(0);
                    for (let i = 0; i < bufferSize; i++) {
                        const white = Math.random() * 2 - 1;
                        data[i] = (this.lastOut + (0.02 * white)) / 1.02;
                        this.lastOut = data[i];
                        data[i] *= 3.5;
                    }
                    this.noiseNode = this.ctx.createBufferSource();
                    this.noiseNode.buffer = buffer;
                    this.noiseNode.loop = true;

                    const gain = this.ctx.createGain();
                    gain.gain.value = 0.05;

                    const filter = this.ctx.createBiquadFilter();
                    filter.type = 'lowpass';
                    filter.frequency.value = 400;

                    this.noiseNode.connect(filter);
                    filter.connect(gain);
                    gain.connect(this.ctx.destination);
                    this.noiseNode.start();
                    this.bgGain = gain;
                } else {
                    if (this.noiseNode) {
                        this.noiseNode.stop();
                        this.noiseNode = null;
                        this.lastOut = 0;
                    }
                }
            },

            speak: function (text) {
                if (this.isMuted) return;
                if (!window.speechSynthesis) return;

                // Cancel current speech to speak new commentary immediately
                window.speechSynthesis.cancel();

                const utterance = new SpeechSynthesisUtterance(text);
                utterance.lang = 'ja-JP';
                utterance.rate = 1.3; // Exciting pace
                utterance.pitch = 1.1; // Slightly higher pitch
                utterance.volume = 1.0;

                window.speechSynthesis.speak(utterance);
            }
        };

        function toggleMute() {
            SoundManager.isMuted = !SoundManager.isMuted;
            document.getElementById('sound-toggle').innerText = SoundManager.isMuted ? 'üîá' : 'üîä';
            if (SoundManager.isMuted) SoundManager.playAtmosphere(false);
        }

        // --- Configuration & Constants ---
        const CONFIG = {
            laneWidth: 3.5,
            trackRadiusX: 180,
            trackRadiusZ: 90,
            segmentCount: 200,
            finishLineT: 0.0,
            startLineT: 0.0,
            raceSpeedMult: 1.0
        };

        const HORSE_DATA = [
            {
                name: "„Éõ„ÉØ„Ç§„Éà„Ç¶„Ç£„É≥„Éâ", color: 0xF0F0F0, skill: "Divine Wind", skillDesc: "„É©„Çπ„Éà„Çπ„Éë„Éº„ÉàË∂ÖÂä†ÈÄü", icon: "üå™Ô∏è",
                check: (p, r) => p > 0.75 && r < 0.02,
                activate: (h) => h.speed *= (1.6 + Math.random() * 0.4)
            },
            {
                name: "„ÉÅ„Éß„Ç≥„ÉÅ„ÉÉ„Éó", color: 0x5D4037, skill: "Sugar Rush", skillDesc: "‰∏≠Áõ§„ÅßÁàÜÁô∫ÁöÑ„Å™Âä†ÈÄü", icon: "üç©",
                check: (p, r) => p > 0.4 && p < 0.6 && r < 0.02,
                activate: (h) => h.speed *= (1.4 + Math.random() * 0.4)
            },
            {
                name: "„Éñ„É©„ÉÉ„ÇØ„Ç∏„É£„ÉÉ„ÇØ", color: 0x212121, skill: "Shadow Step", skillDesc: "„Çπ„Çø„Éü„ÉäÊ∏õ„Çâ„Åö„Å´Âä†ÈÄü", icon: "üåë",
                check: (p, r) => p > 0.5 && r < 0.01,
                activate: (h) => h.speed *= (1.3 + Math.random() * 0.3)
            },
            {
                name: "„Ç¥„Éº„É´„Éá„É≥„Éú„Éº„Ç§", color: 0xFFD700, skill: "Gold Aura", skillDesc: "ÂÖ®‰ΩìÁöÑ„Å™ÈÄüÂ∫¶Â∫ï‰∏ä„Åí", icon: "‚ú®",
                check: (p, r) => p > 0.2 && r < 0.01,
                activate: (h) => { h.speed *= (1.2 + Math.random() * 0.2); h.skillTimer = 6.0; }
            },
            {
                name: "„Ç∑„É´„Éê„Éº„Éñ„É¨„ÉÉ„Éà", color: 0xA9A9A9, skill: "Bullet Time", skillDesc: "„Ç¥„Éº„É´Áõ¥Ââç„Åß‰∏ÄÁû¨„ÅÆ‰º∏„Å≥", icon: "üöÖ",
                check: (p, r) => p > 0.85 && r < 0.03,
                activate: (h) => { h.speed *= (2.0 + Math.random() * 1.0); h.skillTimer = 1.5; }
            }
        ];

        const STATE = {
            wallet: 1000,
            betAmount: 100,
            selectedHorse: null,
            isRacing: false,
            raceStarted: false,
            horses: [],
            gates: [],
            cameraMode: 0, // 0:Follow, 1:Top, 2:Side, 3:Auto(TV Style)
            lastAutoSwitch: 0,
            autoShotType: 0,
            trackCurve: null,
            winner: null,
            weather: null,
            trackCondition: null,
            rainParticles: null,
            isWinningRun: false,
            cameraShake: 0,
            timeScale: 1.0
        };

        // --- Weather System ---
        const WEATHER_TYPES = [
            {
                name: 'Êô¥„Çå',
                icon: '‚òÄ',
                trackCondition: 'ËâØ',
                speedMultiplier: 1.0,
                skyColor: 0x87CEEB,
                fogColor: 0x87CEEB,
                ambientIntensity: 0.6,
                directionalIntensity: 1.2,
                directionalColor: 0xffffff
            },
            {
                name: 'Â§ïÊñπ',
                icon: 'üåÜ',
                trackCondition: 'ËâØ',
                speedMultiplier: 1.0,
                skyColor: 0xFF6B35,
                fogColor: 0xFF8C69,
                ambientIntensity: 0.5,
                directionalIntensity: 0.9,
                directionalColor: 0xFFAA77
            },
            {
                name: 'Èõ®',
                icon: '‚òî',
                trackCondition: 'Èáç',
                speedMultiplier: 0.85,
                skyColor: 0x4A5568,
                fogColor: 0x718096,
                ambientIntensity: 0.4,
                directionalIntensity: 0.7,
                directionalColor: 0xCCCCCC,
                rain: true
            },
            {
                name: 'Â§ú',
                icon: 'üåÉ',
                trackCondition: 'ËâØ',
                speedMultiplier: 1.0,
                skyColor: 0x0A1128,
                fogColor: 0x1A2332,
                ambientIntensity: 0.3,
                directionalIntensity: 1.5,
                directionalColor: 0xFFFFDD,
                night: true
            }
        ];

        // --- Three.js Setup ---
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0x87CEEB);
        scene.fog = new THREE.Fog(0x87CEEB, 40, 350);

        const camera = new THREE.PerspectiveCamera(50, window.innerWidth / window.innerHeight, 0.5, 1000);
        const renderer = new THREE.WebGLRenderer({ antialias: true, powerPreference: "high-performance" });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.shadowMap.enabled = true;
        renderer.shadowMap.type = THREE.PCFSoftShadowMap;
        renderer.outputEncoding = THREE.sRGBEncoding;
        document.body.appendChild(renderer.domElement);

        // --- Lighting ---
        const hemiLight = new THREE.HemisphereLight(0xffffff, 0xffffff, 0.6);
        scene.add(hemiLight);

        const dirLight = new THREE.DirectionalLight(0xffffff, 1.2);
        dirLight.position.set(100, 200, 50);
        dirLight.castShadow = true;
        dirLight.shadow.mapSize.width = 2048;
        dirLight.shadow.mapSize.height = 2048;
        const d = 250;
        dirLight.shadow.camera.left = -d; dirLight.shadow.camera.right = d;
        dirLight.shadow.camera.top = d; dirLight.shadow.camera.bottom = -d;
        scene.add(dirLight);

        // --- Weather Functions ---
        function createRainParticles() {
            const rainGeo = new THREE.BufferGeometry();
            const rainCount = 2000;
            const positions = [];

            for (let i = 0; i < rainCount; i++) {
                positions.push(
                    (Math.random() - 0.5) * 400,
                    Math.random() * 200,
                    (Math.random() - 0.5) * 400
                );
            }

            rainGeo.setAttribute('position', new THREE.Float32BufferAttribute(positions, 3));
            const rainMaterial = new THREE.PointsMaterial({
                color: 0xaaaaaa,
                size: 0.5,
                transparent: true,
                opacity: 0.6
            });

            return new THREE.Points(rainGeo, rainMaterial);
        }

        function applyWeather(weather) {
            // Set sky and fog
            scene.background.setHex(weather.skyColor);
            scene.fog.color.setHex(weather.fogColor);

            // Update lighting
            hemiLight.intensity = weather.ambientIntensity;
            dirLight.intensity = weather.directionalIntensity;
            dirLight.color.setHex(weather.directionalColor);

            // Remove existing rain if any
            if (STATE.rainParticles) {
                scene.remove(STATE.rainParticles);
                STATE.rainParticles = null;
            }

            // Add rain particles if rainy weather
            if (weather.rain) {
                STATE.rainParticles = createRainParticles();
                scene.add(STATE.rainParticles);
            }

            STATE.weather = weather;
            STATE.trackCondition = weather.trackCondition;
        }

        // --- Environment & Track ---
        function createTrackCurve() {
            // Create a more complex, longer track shape
            // Custom points for a unique layout (twisted oval / kidney shape)
            const points = [
                new THREE.Vector3(200, 0, 0),    // Start straight
                new THREE.Vector3(180, 0, 80),   // Turn 1
                new THREE.Vector3(100, 0, 120),  // Turn 1 continued
                new THREE.Vector3(-50, 0, 100),  // Backstretch start
                new THREE.Vector3(-150, 0, 40),  // Backstretch mid
                new THREE.Vector3(-220, 0, 0),   // Backstretch end
                new THREE.Vector3(-180, 0, -80), // Turn 2
                new THREE.Vector3(-50, 0, -120), // Turn 2 continued / S-curve start
                new THREE.Vector3(50, 0, -80),   // S-curve mid
                new THREE.Vector3(150, 0, -60),  // Final turn setup
                new THREE.Vector3(200, 0, 0)     // Loop close
            ];
            return new THREE.CatmullRomCurve3(points, true, 'centripetal');
        }
        STATE.trackCurve = createTrackCurve();

        function buildTrack() {
            // Ground
            const groundGeo = new THREE.PlaneGeometry(1000, 1000);
            const textureLoader = new THREE.TextureLoader();
            const grassTexture = textureLoader.load(
                'textures/grass.png',
                function (texture) {
                    // Ë™≠„ÅøËæº„ÅøÊàêÂäüÊôÇ„ÅÆ„Ç≥„Éº„É´„Éê„ÉÉ„ÇØ
                    console.log('Grass texture loaded successfully');
                    texture.wrapS = THREE.RepeatWrapping;
                    texture.wrapT = THREE.RepeatWrapping;
                    texture.repeat.set(25, 25);
                    texture.needsUpdate = true;
                },
                undefined,
                function (error) {
                    // „Ç®„É©„ÉºÊôÇ„ÅÆ„Ç≥„Éº„É´„Éê„ÉÉ„ÇØÔºö„Éï„Ç©„Éº„É´„Éê„ÉÉ„ÇØ„Å®„Åó„Å¶Canvas„ÅßÁîüÊàê
                    console.warn('Error loading grass texture, using procedural fallback:', error);

                    const canvas = document.createElement('canvas');
                    canvas.width = 512; canvas.height = 512;
                    const ctx = canvas.getContext('2d');
                    ctx.fillStyle = '#4CAF50';
                    ctx.fillRect(0, 0, 512, 512);

                    for (let i = 0; i < 10000; i++) {
                        ctx.fillStyle = Math.random() > 0.5 ? '#66BB6A' : '#388E3C';
                        const size = Math.random() * 3 + 1;
                        ctx.fillRect(Math.random() * 512, Math.random() * 512, size, size);
                    }

                    const fallbackTexture = new THREE.CanvasTexture(canvas);
                    fallbackTexture.wrapS = THREE.RepeatWrapping;
                    fallbackTexture.wrapT = THREE.RepeatWrapping;
                    fallbackTexture.repeat.set(25, 25);

                    ground.material.map = fallbackTexture;
                    ground.material.needsUpdate = true;
                }
            );
            // ÂàùÊúü„Éû„ÉÜ„É™„Ç¢„É´ÔºàË™≠„ÅøËæº„ÅøÂæÖ„Å°‰∏≠„ÅØ‰ªÆ„ÅÆËâ≤„Åã„ÄÅ„ÉÜ„ÇØ„Çπ„ÉÅ„É£„Å™„ÅóÔºâ
            // grassTexture„ÅØÈùûÂêåÊúü„ÅßË®≠ÂÆö„Åï„Çå„Çã„Åü„ÇÅ„ÄÅLoading‰∏≠„ÅØÁôΩ„Å™„Å©„ÅåË°®Á§∫„Åï„Çå„ÇãÂèØËÉΩÊÄß„Åå„ÅÇ„Çã„Åå„ÄÅ
            // GroundÁîüÊàêÊôÇ„Å´map„ÇíÊåáÂÆö„Åó„Å¶„ÅÑ„Çã„ÅÆ„Åß„ÄÅ„É≠„Éº„ÉâÂÆå‰∫ÜÂæå„Å´Ëá™ÂãïÊõ¥Êñ∞„Åï„Çå„Çã„ÅØ„Åö„ÄÇ
            // „Åü„Å†„Åó„É≠„Éº„ÉâÂ§±ÊïóÊôÇ„ÅØonError„ÅåËµ∞„Çã„Åæ„Åß„ÉÜ„ÇØ„Çπ„ÉÅ„É£„ÅåÁÑ°„ÅÑÁä∂ÊÖã„Å´„Å™„Çã„ÄÇ

            grassTexture.wrapS = THREE.RepeatWrapping;
            grassTexture.wrapT = THREE.RepeatWrapping;
            grassTexture.repeat.set(25, 25);
            const groundMat = new THREE.MeshStandardMaterial({ map: grassTexture, roughness: 1.0 });
            const ground = new THREE.Mesh(groundGeo, groundMat);
            ground.rotation.x = -Math.PI / 2;
            ground.receiveShadow = true;
            scene.add(ground);

            // Track Surface (Corrected UVs & Texture)
            const trackWidth = CONFIG.laneWidth * 6;
            const points = STATE.trackCurve.getSpacedPoints(200); // Reduced from 400 for performance
            const vertices = [], uvs = [], indices = [];

            points.forEach((p, i) => {
                const tangent = STATE.trackCurve.getTangentAt(i / 200).normalize();
                const normal = new THREE.Vector3(-tangent.z, 0, tangent.x).normalize();
                const p1 = p.clone().add(normal.clone().multiplyScalar(trackWidth / 2));
                const p2 = p.clone().add(normal.clone().multiplyScalar(-trackWidth / 2));
                vertices.push(p1.x, 0.5, p1.z, p2.x, 0.5, p2.z); // Raised higher to be clearly visible
                const v = i / 10;
                uvs.push(0, v, 1, v);
            });
            for (let i = 0; i < points.length - 1; i++) {
                const offset = i * 2;
                indices.push(offset, offset + 1, offset + 2, offset + 1, offset + 3, offset + 2);
            }
            const trackGeo = new THREE.BufferGeometry();
            trackGeo.setAttribute('position', new THREE.Float32BufferAttribute(vertices, 3));
            trackGeo.setAttribute('uv', new THREE.Float32BufferAttribute(uvs, 2));
            trackGeo.setIndex(indices);
            trackGeo.computeVertexNormals();

            // Dirt Track Texture
            // Dirt Track Texture
            const trackTex = new THREE.TextureLoader().load(
                'textures/dirt.png',
                function (texture) {
                    console.log('Dirt texture loaded successfully');
                    texture.wrapS = THREE.RepeatWrapping;
                    texture.wrapT = THREE.RepeatWrapping;
                    texture.repeat.set(4, 4);
                    texture.needsUpdate = true;
                },
                undefined,
                function (error) {
                    console.warn('Error loading dirt texture, using procedural fallback:', error);
                    const sandCanvas = document.createElement('canvas');
                    sandCanvas.width = 512; sandCanvas.height = 512;
                    const sCtx = sandCanvas.getContext('2d');
                    // Dark brown dirt base
                    sCtx.fillStyle = '#6B4423';
                    sCtx.fillRect(0, 0, 512, 512);
                    // Add dirt texture with varied browns
                    for (let i = 0; i < 10000; i++) {
                        const rand = Math.random();
                        if (rand < 0.4) sCtx.fillStyle = '#8B5A3C';
                        else if (rand < 0.7) sCtx.fillStyle = '#5C3317';
                        else sCtx.fillStyle = '#A0522D';
                        const size = Math.random() < 0.8 ? 2 : 4;
                        sCtx.fillRect(Math.random() * 512, Math.random() * 512, size, size);
                    }
                    const fallback = new THREE.CanvasTexture(sandCanvas);
                    fallback.wrapS = THREE.RepeatWrapping;
                    fallback.wrapT = THREE.RepeatWrapping;
                    fallback.repeat.set(4, 4);
                    trackMesh.material.map = fallback;
                    trackMesh.material.needsUpdate = true;
                }
            );

            trackTex.wrapS = THREE.RepeatWrapping;
            trackTex.wrapT = THREE.RepeatWrapping;
            trackTex.repeat.set(4, 4);

            const trackMesh = new THREE.Mesh(trackGeo, new THREE.MeshStandardMaterial({
                map: trackTex,
                color: 0xffffff,
                roughness: 1.0,
                side: THREE.DoubleSide
            }));
            trackMesh.receiveShadow = true;
            trackMesh.castShadow = true;
            scene.add(trackMesh);

            // Objects
            const innerRailPoints = [], outerRailPoints = [];
            // Re-use geometries and materials for performance
            const poleGeo = new THREE.CylinderGeometry(0.1, 0.1, 1.2);
            const poleMat = new THREE.MeshStandardMaterial({ color: 0xffffff });

            points.forEach((p, i) => {
                const tangent = STATE.trackCurve.getTangentAt(i / 200).normalize();
                const normal = new THREE.Vector3(-tangent.z, 0, tangent.x).normalize();

                // Add poles less frequently
                if (i % 5 === 0) {
                    const posIn = p.clone().add(normal.clone().multiplyScalar(trackWidth / 2 * 1.05));
                    const poleIn = new THREE.Mesh(poleGeo, poleMat); poleIn.position.set(posIn.x, 0.6, posIn.z);
                    scene.add(poleIn);

                    const posOut = p.clone().add(normal.clone().multiplyScalar(-trackWidth / 2 * 1.05));
                    const poleOut = new THREE.Mesh(poleGeo, poleMat); poleOut.position.set(posOut.x, 0.6, posOut.z);
                    scene.add(poleOut);
                }
                innerRailPoints.push(p.clone().add(normal.clone().multiplyScalar(trackWidth / 2 * 1.05)).setY(1.0));
                outerRailPoints.push(p.clone().add(normal.clone().multiplyScalar(-trackWidth / 2 * 1.05)).setY(1.0));
            });
            scene.add(new THREE.Mesh(new THREE.TubeGeometry(new THREE.CatmullRomCurve3(innerRailPoints, true), 200, 0.08, 6, true), new THREE.MeshStandardMaterial({ color: 0xffffff })));
            scene.add(new THREE.Mesh(new THREE.TubeGeometry(new THREE.CatmullRomCurve3(outerRailPoints, true), 200, 0.08, 6, true), new THREE.MeshStandardMaterial({ color: 0xffffff })));

            const goalT = CONFIG.finishLineT;
            const goalPoint = STATE.trackCurve.getPointAt(goalT);
            const prevPoint = STATE.trackCurve.getPointAt(0.99);
            const goalGroup = new THREE.Group();
            goalGroup.position.copy(goalPoint); goalGroup.lookAt(prevPoint);
            const postGeo = new THREE.CylinderGeometry(0.3, 0.3, 8); const postMat = new THREE.MeshStandardMaterial({ color: 0xffffff });
            const gp1 = new THREE.Mesh(postGeo, postMat); gp1.position.set(-trackWidth / 2 - 1, 4, 0);
            const gp2 = new THREE.Mesh(postGeo, postMat); gp2.position.set(trackWidth / 2 + 1, 4, 0);
            const banner = new THREE.Mesh(new THREE.BoxGeometry(trackWidth + 4, 2, 0.5), new THREE.MeshStandardMaterial({ color: 0xB71C1C }));
            banner.position.set(0, 7, 0);
            const tCtx = document.createElement('canvas').getContext('2d'); tCtx.canvas.width = 256; tCtx.canvas.height = 64;
            tCtx.fillStyle = '#B71C1C'; tCtx.fillRect(0, 0, 256, 64); tCtx.fillStyle = 'white'; tCtx.font = 'bold 40px Arial'; tCtx.textAlign = 'center'; tCtx.textBaseline = 'middle'; tCtx.fillText('GOAL', 128, 32);
            banner.material = new THREE.MeshStandardMaterial({ map: new THREE.CanvasTexture(tCtx.canvas) });
            goalGroup.add(gp1, gp2, banner); scene.add(goalGroup);

            const standGroup = new THREE.Group();
            standGroup.add(new THREE.Mesh(new THREE.BoxGeometry(60, 20, 30), new THREE.MeshStandardMaterial({ color: 0xffffff })).translateX(0).translateY(10));
            standGroup.add(new THREE.Mesh(new THREE.BoxGeometry(64, 2, 40), new THREE.MeshStandardMaterial({ color: 0xeeeeee })).translateY(25).translateZ(5));
            const goalTangent = STATE.trackCurve.getTangentAt(goalT).normalize();
            const goalNormal = new THREE.Vector3(-goalTangent.z, 0, goalTangent.x).normalize();
            standGroup.position.copy(goalPoint.clone().add(goalNormal.multiplyScalar(-45))); standGroup.lookAt(goalPoint); scene.add(standGroup);

            // Trees - Improved Realism (3-Tier Pine Trees)
            // Reusing geometries for performance
            const trunkGeo = new THREE.CylinderGeometry(0.4, 0.6, 2.5, 7);
            const trunkMat = new THREE.MeshStandardMaterial({ color: 0x4A3828, roughness: 0.9 });

            const foliageGeo1 = new THREE.ConeGeometry(3.0, 4.0, 7); // Bottom
            const foliageGeo2 = new THREE.ConeGeometry(2.3, 3.5, 7); // Middle
            const foliageGeo3 = new THREE.ConeGeometry(1.6, 3.0, 7); // Top
            const foliageMat = new THREE.MeshStandardMaterial({
                color: 0x2E7D32,
                roughness: 0.8,
                flatShading: true // Low-poly style look
            });

            const treeCount = 60; // Increased density slightly
            for (let i = 0; i < treeCount; i++) {
                const t = Math.random();
                const p = STATE.trackCurve.getPointAt(t);
                const tan = STATE.trackCurve.getTangentAt(t).normalize();
                const nor = new THREE.Vector3(-tan.z, 0, tan.x).normalize();

                const dist = 35 + Math.random() * 60;
                const side = Math.random() > 0.3 ? 1 : -1;
                const treePos = p.add(nor.multiplyScalar(dist * side));

                const tree = new THREE.Group();

                // Trunk
                const trunk = new THREE.Mesh(trunkGeo, trunkMat);
                trunk.position.y = 1.25;
                trunk.castShadow = true;
                trunk.receiveShadow = true;
                tree.add(trunk);

                // Foliage Levels
                const l1 = new THREE.Mesh(foliageGeo1, foliageMat);
                l1.position.y = 3.0;
                l1.castShadow = true;
                l1.receiveShadow = true;
                l1.rotation.y = Math.random() * Math.PI; // Random rotation per layer
                tree.add(l1);

                const l2 = new THREE.Mesh(foliageGeo2, foliageMat);
                l2.position.y = 5.0;
                l2.castShadow = true;
                l2.receiveShadow = true;
                l2.rotation.y = Math.random() * Math.PI;
                tree.add(l2);

                const l3 = new THREE.Mesh(foliageGeo3, foliageMat);
                l3.position.y = 7.0;
                l3.castShadow = true;
                l3.receiveShadow = true;
                l3.rotation.y = Math.random() * Math.PI;
                tree.add(l3);

                // Random Variation
                const scale = 0.8 + Math.random() * 0.6;
                tree.scale.set(scale, scale, scale);
                tree.rotation.y = Math.random() * Math.PI * 2;

                tree.position.copy(treePos);
                scene.add(tree);
            }
        }

        document.getElementById('progress-bar').style.width = '50%';
        buildTrack();

        // --- Gate Class ---
        const GATE_GEO = {
            post: new THREE.BoxGeometry(0.2, 4, 0.2),
            top: new THREE.BoxGeometry(3.2, 0.4, 0.4),
            door: new THREE.BoxGeometry(1.4, 3, 0.1),
            bars: new THREE.BoxGeometry(1.2, 2.5, 0.15)
        };

        class Gate {
            constructor(laneOffset) {
                this.mesh = new THREE.Group();
                const t = CONFIG.startLineT;
                const point = STATE.trackCurve.getPointAt(t);
                const tangent = STATE.trackCurve.getTangentAt(t).normalize();
                const normal = new THREE.Vector3(-tangent.z, 0, tangent.x).normalize();
                const pos = point.add(normal.multiplyScalar(laneOffset));
                this.mesh.position.copy(pos); this.mesh.lookAt(pos.clone().add(tangent));

                const mat = new THREE.MeshStandardMaterial({ color: 0x222222, roughness: 0.5 });
                const doorMat = new THREE.MeshStandardMaterial({ color: 0xdddddd, roughness: 0.5 });

                const p1 = new THREE.Mesh(GATE_GEO.post, mat); p1.position.set(-1.5, 2, 0);
                const p2 = new THREE.Mesh(GATE_GEO.post, mat); p2.position.set(1.5, 2, 0);
                const top = new THREE.Mesh(GATE_GEO.top, mat); top.position.set(0, 3.8, 0);
                this.mesh.add(p1, p2, top);

                const createDoor = (isLeft) => {
                    const group = new THREE.Group(); group.position.set(isLeft ? -1.5 : 1.5, 2, 0);
                    const door = new THREE.Mesh(GATE_GEO.door, doorMat); door.position.set(isLeft ? 0.7 : -0.7, 0, 0);
                    const bars = new THREE.Mesh(GATE_GEO.bars, new THREE.MeshStandardMaterial({ color: 0xffffff, wireframe: true }));
                    bars.position.set(isLeft ? 0.7 : -0.7, 0, 0);
                    group.add(door, bars);
                    return group;
                };
                this.leftDoor = createDoor(true); this.rightDoor = createDoor(false);
                this.mesh.add(this.leftDoor, this.rightDoor);
                this.isOpen = false; scene.add(this.mesh);
            }
            open() { this.isOpen = true; }
            reset() { this.isOpen = false; this.leftDoor.rotation.y = 0; this.rightDoor.rotation.y = 0; }
            update(delta) {
                if (this.isOpen && this.leftDoor.rotation.y < 1.8) {
                    const speed = 8.0; this.leftDoor.rotation.y += delta * speed; this.rightDoor.rotation.y -= delta * speed;
                }
            }
        }

        // --- Spectator System ---
        class SpectatorManager {
            constructor(scene, count = 1500) {
                this.scene = scene;
                this.count = count;
                this.dummy = new THREE.Object3D();

                // Low-poly spectator geometry - INCREASED SIZE for visibility
                const geometry = new THREE.BoxGeometry(1.2, 2.0, 1.2);
                const material = new THREE.MeshStandardMaterial({
                    color: 0xffffff,
                    roughness: 0.8
                });

                this.mesh = new THREE.InstancedMesh(geometry, material, count);
                this.mesh.instanceMatrix.setUsage(THREE.DynamicDrawUsage);
                this.mesh.castShadow = true;
                this.mesh.receiveShadow = true;

                // Position the entire mesh group to match the stand location
                const goalT = CONFIG.finishLineT;
                const goalPoint = STATE.trackCurve.getPointAt(goalT);
                const goalTangent = STATE.trackCurve.getTangentAt(goalT).normalize();
                const goalNormal = new THREE.Vector3(-goalTangent.z, 0, goalTangent.x).normalize();

                // Same transform as the Stand Group in buildTrack
                // Start from the same base position: goalPoint + -45 * goalNormal
                const standDistance = 45;
                const standPos = goalPoint.clone().add(goalNormal.multiplyScalar(-standDistance));

                this.mesh.position.copy(standPos);
                this.mesh.lookAt(goalPoint);

                // Important: Add to scene
                this.scene.add(this.mesh);

                this.spectators = [];
                const colors = [0xff0000, 0x00ff00, 0x0000ff, 0xffff00, 0xff00ff, 0x00ffff, 0xffffff, 0x111111, 0xFF9800, 0x4CAF50];

                // Grid layout for "Bleachers" style - REDUCED density for visibility
                const rows = 12;
                const cols = 40;
                const standWidth = 55; // Slightly less than BoxWidth 60

                // Stand Local Dimensions (Approx from buildTrack box geometry)
                // Box(60, 20, 30) translated Y+10.
                // Local Y range of top surface: ~20.
                // Local Z range: -15 to +15.
                // We want stairs going back and up.

                // Let's assume the "front" of the stand is at Z=+15 (closer to track) and "back" is Z=-15.
                const depthStart = 12; // Front of stand (local Z)
                const depthEnd = -12; // Back of stand
                const heightStart = 21; // Bottom of seating area (on top of box)
                const heightEnd = 35; // Top of seating area

                let index = 0;
                for (let r = 0; r < rows; r++) {
                    const rowProgress = r / (rows - 1);
                    // Z goes from Positive (Front) to Negative (Back)
                    const z = depthStart - (rowProgress * (depthStart - depthEnd));
                    // Y goes from Low to High
                    const y = heightStart + (rowProgress * (heightEnd - heightStart));

                    for (let c = 0; c < cols; c++) {
                        if (index >= count) break;

                        // Spread columns centered
                        const colProgress = c / (cols - 1);
                        const x = (colProgress - 0.5) * standWidth;

                        // Add some randomness
                        const randX = (Math.random() - 0.5) * 0.4;
                        const randZ = (Math.random() - 0.5) * 0.2;

                        // Local position relative to the mesh group
                        const pos = new THREE.Vector3(x + randX, y, z + randZ);
                        const color = new THREE.Color(colors[Math.floor(Math.random() * colors.length)]);

                        this.mesh.setColorAt(index, color);

                        this.spectators.push({
                            basePos: pos, // Local position
                            offsetY: Math.random() * 0.5,
                            jumpPhase: Math.random() * Math.PI * 2,
                            speed: 0.5 + Math.random()
                        });

                        this.dummy.position.copy(pos);
                        this.dummy.rotation.set(0, 0, 0); // Reset rotation to local aligned
                        this.dummy.updateMatrix();
                        this.mesh.setMatrixAt(index, this.dummy.matrix);

                        index++;
                    }
                }
                this.mesh.instanceMatrix.needsUpdate = true;
            }

            update(time, leaderProgress) {
                // Determine excitement level
                const isExcited = (leaderProgress > 0.92 && leaderProgress < 1.0) || STATE.winner;
                const jumpBaseSpeed = isExcited ? 15 : 2;
                const jumpBaseHeight = isExcited ? 0.6 : 0.05;

                for (let i = 0; i < this.spectators.length; i++) {
                    const s = this.spectators[i]; // Use length instead of count just in case
                    if (!s) break;

                    // Simple jump animation
                    const yAnim = Math.sin(time * jumpBaseSpeed * s.speed + s.jumpPhase) * jumpBaseHeight;

                    this.dummy.position.copy(s.basePos);
                    this.dummy.position.y += Math.max(0, yAnim);
                    this.dummy.updateMatrix();
                    this.mesh.setMatrixAt(i, this.dummy.matrix);
                }
                this.mesh.instanceMatrix.needsUpdate = true;
            }
        }

        let spectatorManager;

        // --- Particle System ---
        const ParticleType = { DUST: 0, SPLASH: 1, SKILL: 2 };

        class ParticleManager {
            constructor(scene, maxParticles = 3000) {
                this.maxParticles = maxParticles;
                this.particleCount = 0;
                this.scene = scene;

                // Geometry setup
                this.geometry = new THREE.BufferGeometry();
                this.positions = new Float32Array(maxParticles * 3);
                this.colors = new Float32Array(maxParticles * 3);
                this.sizes = new Float32Array(maxParticles);

                this.geometry.setAttribute('position', new THREE.BufferAttribute(this.positions, 3));
                this.geometry.setAttribute('color', new THREE.BufferAttribute(this.colors, 3));
                this.geometry.setAttribute('size', new THREE.BufferAttribute(this.sizes, 1));

                // Texture Loading
                const textureLoader = new THREE.TextureLoader();
                // If we had a real file we would load it, but we fallback to generated canvas
                this.sparkleTexture = this.createSparkleTexture();

                this.material = new THREE.PointsMaterial({
                    size: 1,
                    vertexColors: true,
                    map: this.sparkleTexture, // Use sparkle texture for everything (looks okay for dust too, or mix)
                    transparent: true,
                    opacity: 0.8,
                    depthWrite: false,
                    blending: THREE.AdditiveBlending // Additive for glowing effect
                });

                this.mesh = new THREE.Points(this.geometry, this.material);
                this.mesh.frustumCulled = false;
                scene.add(this.mesh);

                // Particle data
                this.particles = [];
                for (let i = 0; i < maxParticles; i++) {
                    this.particles.push({
                        active: false,
                        life: 0,
                        maxLife: 1.0,
                        velocity: new THREE.Vector3(),
                        type: ParticleType.DUST
                    });
                    this.positions[i * 3 + 1] = -1000;
                }
            }

            createSparkleTexture() {
                const canvas = document.createElement('canvas');
                canvas.width = 64; canvas.height = 64;
                const ctx = canvas.getContext('2d');

                // Draw star shape
                const cx = 32, cy = 32, spikes = 4, outerRadius = 30, innerRadius = 5;
                let rot = Math.PI / 2 * 3;
                let x = cx, y = cy;
                const step = Math.PI / spikes;

                ctx.beginPath();
                ctx.moveTo(cx, cy - outerRadius);
                for (let i = 0; i < spikes; i++) {
                    x = cx + Math.cos(rot) * outerRadius;
                    y = cy + Math.sin(rot) * outerRadius;
                    ctx.lineTo(x, y);
                    rot += step;

                    x = cx + Math.cos(rot) * innerRadius;
                    y = cy + Math.sin(rot) * innerRadius;
                    ctx.lineTo(x, y);
                    rot += step;
                }
                ctx.lineTo(cx, cy - outerRadius);
                ctx.closePath();

                // Radial Gradient for bloom
                const grad = ctx.createRadialGradient(cx, cy, 0, cx, cy, 32);
                grad.addColorStop(0, 'rgba(255, 255, 255, 1)');
                grad.addColorStop(0.4, 'rgba(255, 255, 255, 0.8)');
                grad.addColorStop(1, 'rgba(255, 255, 255, 0)');

                ctx.fillStyle = grad;
                ctx.fill();

                const texture = new THREE.CanvasTexture(canvas);
                return texture;
            }

            spawn(pos, type) {
                let index = -1;
                for (let i = 0; i < this.maxParticles; i++) {
                    if (!this.particles[i].active) {
                        index = i;
                        break;
                    }
                }

                if (index === -1) return;

                const p = this.particles[index];
                p.active = true;
                p.type = type;

                this.positions[index * 3] = pos.x;
                this.positions[index * 3 + 1] = pos.y;
                this.positions[index * 3 + 2] = pos.z;

                if (type === ParticleType.SKILL) {
                    p.life = 1.0 + Math.random() * 0.5;
                    p.maxLife = p.life;
                    // Upward spiral / burst
                    p.velocity.set(
                        (Math.random() - 0.5) * 6,
                        Math.random() * 10 + 5,
                        (Math.random() - 0.5) * 6
                    );
                    // Gold/White
                    this.colors[index * 3] = 1.0;
                    this.colors[index * 3 + 1] = 0.9;
                    this.colors[index * 3 + 2] = 0.4;
                    this.sizes[index] = Math.random() * 8 + 4;

                } else if (type === ParticleType.DUST) {
                    p.life = 0.5 + Math.random() * 0.5;
                    p.maxLife = p.life;
                    p.velocity.set(
                        (Math.random() - 0.5) * 4,
                        Math.random() * 2 + 1,
                        (Math.random() - 0.5) * 4
                    );
                    // Dusty Brown (lightened for additive blending)
                    this.colors[index * 3] = 0.5;
                    this.colors[index * 3 + 1] = 0.4;
                    this.colors[index * 3 + 2] = 0.3;
                    this.sizes[index] = Math.random() * 4 + 2;
                } else { // SPLASH
                    p.life = 0.4 + Math.random() * 0.3;
                    p.maxLife = p.life;
                    p.velocity.set(
                        (Math.random() - 0.5) * 6,
                        Math.random() * 5 + 3,
                        (Math.random() - 0.5) * 6
                    );
                    // Watery Blue
                    this.colors[index * 3] = 0.4;
                    this.colors[index * 3 + 1] = 0.6;
                    this.colors[index * 3 + 2] = 1.0;
                    this.sizes[index] = Math.random() * 3 + 1;
                }
            }

            update(delta) {
                for (let i = 0; i < this.maxParticles; i++) {
                    const p = this.particles[i];
                    if (!p.active) continue;

                    p.life -= delta;
                    if (p.life <= 0) {
                        p.active = false;
                        this.positions[i * 3 + 1] = -1000;
                        this.sizes[i] = 0;
                        continue;
                    }

                    // Physics
                    this.positions[i * 3] += p.velocity.x * delta * 5;
                    this.positions[i * 3 + 1] += p.velocity.y * delta * 5;
                    this.positions[i * 3 + 2] += p.velocity.z * delta * 5;

                    if (p.type === ParticleType.SKILL) {
                        p.velocity.y += delta * 2; // Rise
                        // Twinkle size
                        this.sizes[i] = (Math.sin(Date.now() * 0.01 + i) * 0.5 + 1) * (p.life / p.maxLife * 8);
                    } else if (p.type === ParticleType.DUST) {
                        p.velocity.y *= 0.95;
                        const r = p.life / p.maxLife;
                        this.sizes[i] = (1 - r) * 5 + 2;
                    } else { // SPLASH
                        p.velocity.y -= delta * 25;
                        const r = p.life / p.maxLife;
                        this.sizes[i] = r * 3;
                    }
                }

                this.geometry.attributes.position.needsUpdate = true;
                this.geometry.attributes.color.needsUpdate = true;
                this.geometry.attributes.size.needsUpdate = true;
            }
        }

        const particleManager = new ParticleManager(scene);

        // --- Confetti System ---
        class ConfettiManager {
            constructor(scene, count = 1000) {
                this.count = count;
                this.scene = scene;
                this.active = false;

                const geometry = new THREE.PlaneGeometry(0.3, 0.3);
                const material = new THREE.MeshBasicMaterial({ side: THREE.DoubleSide });
                this.mesh = new THREE.InstancedMesh(geometry, material, count);
                this.mesh.instanceMatrix.setUsage(THREE.DynamicDrawUsage);

                this.dummy = new THREE.Object3D();
                this.particles = [];

                const colors = [0xFF0000, 0x00FF00, 0x0000FF, 0xFFFF00, 0xFF00FF, 0x00FFFF, 0xFFFFFF];

                for (let i = 0; i < count; i++) {
                    this.particles.push({
                        pos: new THREE.Vector3(),
                        vel: new THREE.Vector3(),
                        rot: new THREE.Vector3(),
                        rotVel: new THREE.Vector3(),
                        color: new THREE.Color(colors[Math.floor(Math.random() * colors.length)])
                    });
                    this.mesh.setColorAt(i, this.particles[i].color);
                }

                this.mesh.visible = false;
                scene.add(this.mesh);
            }

            start(centerPos) {
                this.active = true;
                this.mesh.visible = true;
                this.particles.forEach((p, i) => {
                    // Spawn area around the winner
                    p.pos.set(
                        centerPos.x + (Math.random() - 0.5) * 40,
                        centerPos.y + 20 + Math.random() * 20,
                        centerPos.z + (Math.random() - 0.5) * 40
                    );
                    p.vel.set(
                        (Math.random() - 0.5) * 0.5,
                        -(Math.random() * 0.2 + 0.1),
                        (Math.random() - 0.5) * 0.5
                    );
                    p.rot.set(Math.random() * Math.PI, Math.random() * Math.PI, Math.random() * Math.PI);
                    p.rotVel.set(Math.random() * 0.2, Math.random() * 0.2, Math.random() * 0.2);

                    this.updateParticle(i, p);
                });
                this.mesh.instanceMatrix.needsUpdate = true;
            }

            stop() {
                this.active = false;
                this.mesh.visible = false;
            }

            updateParticle(i, p) {
                this.dummy.position.copy(p.pos);
                this.dummy.rotation.set(p.rot.x, p.rot.y, p.rot.z);
                this.dummy.updateMatrix();
                this.mesh.setMatrixAt(i, this.dummy.matrix);
            }

            update(delta) {
                if (!this.active) return;

                this.particles.forEach((p, i) => {
                    p.pos.add(p.vel);
                    p.rot.x += p.rotVel.x;
                    p.rot.y += p.rotVel.y;
                    p.rot.z += p.rotVel.z;

                    // Swing effect
                    p.pos.x += Math.sin(Date.now() * 0.001 + i) * 0.02;

                    // Reset if too low
                    if (p.pos.y < 0) {
                        p.pos.y = 40;
                    }

                    this.updateParticle(i, p);
                });
                this.mesh.instanceMatrix.needsUpdate = true;
            }
        }
        const confettiManager = new ConfettiManager(scene);

        // --- Horse Class ---
        class Horse {
            constructor(id, data) {
                this.id = id; this.name = data.name; this.skillName = data.skill; this.skillDesc = data.skillDesc; this.icon = data.icon;
                this.checkSkill = data.check; this.applySkill = data.activate; // Store logic
                this.mesh = new THREE.Group();
                this.currentT = 0; this.speed = 0;
                this.baseSpeed = (0.045 + Math.random() * 0.01) * CONFIG.raceSpeedMult;
                this.maxSpeed = this.baseSpeed * 1.5;
                this.stamina = 1.0; this.finished = false; this.finishRank = null;
                this.skillTriggered = false; this.skillActive = false; this.skillTimer = 0;
                this.laneOffset = (id - 2) * CONFIG.laneWidth;
                this.createModel(data.color); scene.add(this.mesh); this.reset();
            }
            // ... (createModel and reset methods remain unchanged, just skipped in this diff for brevity if they are not needing changes, but I need to be careful about line numbers. I will replace the whole block to be safe)

            createModel(colorHex) {
                this.mat = new THREE.MeshStandardMaterial({ color: colorHex, roughness: 0.4, metalness: 0.1 });
                const body = new THREE.Mesh(new THREE.BoxGeometry(1, 1, 2), this.mat); body.position.y = 2; body.castShadow = true; this.body = body;
                const neck = new THREE.Mesh(new THREE.BoxGeometry(0.5, 1.2, 0.8), this.mat); neck.position.set(0, 2.8, 0.8); neck.rotation.x = -0.5; neck.castShadow = true;
                const head = new THREE.Mesh(new THREE.BoxGeometry(0.6, 0.7, 1.2), this.mat); head.position.set(0, 3.6, 1.4); head.castShadow = true;
                this.legs = [];
                const legG = new THREE.CylinderGeometry(0.15, 0.1, 1.5);
                [[-0.3, 0.6], [0.3, 0.6], [-0.3, -0.8], [0.3, -0.8]].forEach(p => {
                    const g = new THREE.Group(); g.position.set(p[0], 1.5, p[1]);
                    const l = new THREE.Mesh(legG, this.mat); l.position.y = -0.75; l.castShadow = true;
                    g.add(l); this.mesh.add(g); this.legs.push(g);
                });
                const tail = new THREE.Mesh(new THREE.BoxGeometry(0.2, 0.8, 0.2), this.mat); tail.position.set(0, 2.2, -1.0); tail.rotation.x = 0.5; this.tail = tail;
                this.mesh.add(body, neck, head, tail);
                const auraGeo = new THREE.SphereGeometry(2.5, 16, 16);
                const auraMat = new THREE.MeshBasicMaterial({ color: 0xffff00, wireframe: true, transparent: true, opacity: 0 });
                this.aura = new THREE.Mesh(auraGeo, auraMat); this.aura.visible = false; this.mesh.add(this.aura);
            }

            reset() {
                this.currentT = CONFIG.startLineT; this.finished = false; this.finishRank = null; this.speed = 0;
                // Race variability: reroll stats per race
                const weatherMultiplier = STATE.weather ? STATE.weather.speedMultiplier : 1.0;
                this.baseSpeed = (0.045 + Math.random() * 0.012) * CONFIG.raceSpeedMult * weatherMultiplier;
                this.maxSpeed = this.baseSpeed * (1.4 + Math.random() * 0.3);

                this.skillTriggered = false; this.skillActive = false; this.skillTimer = 0;
                this.mat.emissive.setHex(0x000000); this.aura.visible = false;
                this.legs.forEach(l => l.rotation.x = 0); this.updatePosition();
            }

            activateSkill() {
                if (this.skillTriggered) return;
                if (STATE.winner) return; // No skills after winner decided
                this.skillTriggered = true; this.skillActive = true; this.skillTimer = 3.0;
                showCutIn(this.name, this.skillName, this.icon);
                SoundManager.playSkill();
                this.mat.emissive.setHex(0xaaaaaa); // Brighter emission
                this.aura.visible = true; this.aura.material.opacity = 0.8;

                // --- NEW EFFECTS ---
                // 1. Camera Shake
                STATE.cameraShake = 0.5; // Intensity

                // 2. Speed Lines (Only if player horse or close to player)
                // For dramatic effect, show if player horse or if currently viewing this horse
                const isPlayer = (this.id === STATE.selectedHorse);
                if (isPlayer) {
                    const sl = document.getElementById('speed-lines');
                    sl.classList.add('active');
                    setTimeout(() => sl.classList.remove('active'), 1500);
                }

                // 3. Initial Particle Burst
                for (let i = 0; i < 20; i++) {
                    particleManager.spawn(this.mesh.position.clone().add(new THREE.Vector3(0, 2, 0)), ParticleType.SKILL);
                }

                // Execute logical effect from data
                if (this.applySkill) this.applySkill(this);
            }

            updatePosition() {
                const t = this.currentT % 1.0;
                const point = STATE.trackCurve.getPointAt(t);
                const tangent = STATE.trackCurve.getTangentAt(t).normalize();
                const normal = new THREE.Vector3(-tangent.z, 0, tangent.x).normalize();
                const pos = point.add(normal.multiplyScalar(this.laneOffset));
                const backward = tangent.clone().multiplyScalar(-1.5);
                pos.add(backward);
                this.mesh.position.copy(pos); this.mesh.lookAt(pos.clone().add(tangent));
            }

            update(delta) {
                if (this.finished && !STATE.isWinningRun) {
                    this.legs.forEach(l => l.rotation.x = 0);
                    return;
                }

                if (this.speed < this.baseSpeed) this.speed += delta * 0.05;

                const progress = this.currentT;
                if (!this.skillTriggered && this.speed > 0.01) {
                    const r = Math.random();
                    // Use data-driven check
                    if (this.checkSkill && this.checkSkill(progress, r)) {
                        this.activateSkill();
                    }
                }

                if (this.skillActive) {
                    this.skillTimer -= delta;
                    this.aura.rotation.y += delta * 5;
                    this.aura.scale.setScalar(1.0 + Math.sin(Date.now() * 0.01) * 0.2);
                    if (this.skillTimer <= 0) {
                        this.skillActive = false;
                        this.mat.emissive.setHex(0x000000);
                        this.aura.visible = false;
                    }
                } else {
                    // Random speed fluctuations (simulated jockeying)
                    if (Math.random() < 0.05) this.speed += (Math.random() - 0.5) * 0.001;
                }

                this.currentT += this.speed * delta;
                this.updatePosition();

                if (this.currentT >= 1.0 && !this.finished) {
                    this.finished = true;
                    this.body.position.y += 1;
                }

                const runFreq = 20 + (this.speed * 200); const animT = Date.now() * 0.001;
                this.body.position.y = 2 + Math.sin(animT * runFreq) * 0.1;
                this.legs[0].rotation.x = Math.sin(animT * runFreq) * 0.8;
                this.legs[1].rotation.x = Math.sin(animT * runFreq + Math.PI) * 0.8;
                this.legs[2].rotation.x = Math.sin(animT * runFreq + Math.PI / 2) * 0.8;
                this.legs[3].rotation.x = Math.sin(animT * runFreq - Math.PI / 2) * 0.8;

                // Particle Emission
                if (this.skillActive) {
                    if (Math.random() < 0.3) {
                        const emitPos = this.mesh.position.clone();
                        emitPos.y += Math.random() * 3;
                        emitPos.x += (Math.random() - 0.5) * 1.5;
                        emitPos.z += (Math.random() - 0.5) * 1.5;
                        particleManager.spawn(emitPos, ParticleType.SKILL);
                    }
                }

                if (this.speed > 0.02) {
                    const chance = this.speed * 5; // Higher speed = more particles
                    if (Math.random() < chance) {
                        const type = (STATE.weather && STATE.weather.rain) ? ParticleType.SPLASH : ParticleType.DUST;
                        // Emit from base of horse approximate pos
                        const emitPos = this.mesh.position.clone();
                        emitPos.y = 0.5; // Near ground
                        // Add some randomness around the feet area
                        emitPos.x += (Math.random() - 0.5) * 1.0;
                        emitPos.z += (Math.random() - 0.5) * 1.0;
                        particleManager.spawn(emitPos, type);
                    }
                }
            }
        }

        // --- Commentary System ---
        let lastCommentTime = 0;
        let lastLeader = null;
        let commentQueue = [];
        const box = document.getElementById('commentary-box');
        const txt = document.getElementById('commentary-text');

        function announce(msg) {
            txt.innerText = msg;
            box.classList.add('active');
            SoundManager.speak(msg); // Read aloud
            setTimeout(() => {
                if (txt.innerText === msg) box.classList.remove('active');
            }, 3000);
        }

        function updateCommentary(time) {
            if (time - lastCommentTime < 3.5) return;
            const sorted = [...STATE.horses].sort((a, b) => b.currentT - a.currentT);
            const leader = sorted[0];
            const second = sorted[1];
            const p = leader.currentT;
            let msg = "";

            if (p < 0.1) {
                // Keep initial start simple to avoid overlap with gate open
            } else if (p > 0.15 && p < 0.2) {
                const phrases = [
                    `ÂÖàÊâã„ÇíÂ•™„Å£„Åü„ÅÆ„ÅØ ${leader.name} „Åß„ÅôÔºÅ`,
                    `${leader.name} „ÅåÊûúÊï¢„Å´„Éè„Éä„Çí‰∏ªÂºµ„Åó„Åæ„Åó„ÅüÔºÅ`,
                    `„Åæ„Åö„ÅØ ${leader.name} „Åå„É¨„Éº„Çπ„ÇíÂºï„Å£Âºµ„Çä„Åæ„Åô„ÄÇ`
                ];
                msg = phrases[Math.floor(Math.random() * phrases.length)];
            } else if (p > 0.45 && p < 0.5) {
                const phrases = [
                    "„É¨„Éº„Çπ„ÅØ‰∏≠Áõ§„ÄÅÂêë„Åì„ÅÜÊ≠£Èù¢„Å´ÂÖ•„Å£„Å¶„ÅÑ„Åæ„ÅôÔºÅ",
                    "ÂêÑÈ¶¨„ÄÅÊ∑°„ÄÖ„Å®„Åó„Åü„Éö„Éº„Çπ„ÅßÈÄ≤„Çì„Åß„ÅÑ„Åæ„Åô„ÄÇ",
                    `${leader.name}„ÄÅËªΩÂø´„Å™ÈÄÉ„Åí„ÇíË¶ã„Åõ„Å¶„ÅÑ„Åæ„ÅôÔºÅ`,
                    "ÂÖàÈ†≠„Åã„ÇâÊúÄÂæåÊñπ„Åæ„Åß„ÄÅÈöäÂàó„ÅØÁ∏¶Èï∑„Å´„Å™„Å£„Å¶„ÅÑ„Åæ„ÅôÔºÅ",
                    "„Åä„Å£„Å®„ÄÅÂæåÊñπ„Åã„Çâ‰∏ÄÊ∞ó„Å´È¶¨Áæ§„ÅåÂãï„ÅçÂá∫„Åó„ÅüÔºÅ"
                ];
                msg = phrases[Math.floor(Math.random() * phrases.length)];
            } else if (p > 0.7 && p < 0.75) {
                const phrases = [
                    "„Åï„ÅÇ„ÄÅÁ¨¨3„Ç≥„Éº„Éä„Éº„Åã„ÇâÁ¨¨4„Ç≥„Éº„Éä„Éº„Å∏ÔºÅ",
                    "ÂãùË≤†„Å©„Åì„ÇçÔºÅÂêÑÈ¶¨„Çπ„Éë„Éº„Éà„ÅÆ‰ΩìÂã¢„Å´ÂÖ•„Çä„Åæ„ÅôÔºÅ",
                    "ÂæåÁ∂ö„ÇÇÂ∑Æ„ÇíË©∞„ÇÅ„Å¶„Åç„ÅüÔºÅÊ∑∑Êà¶Ê®°Êßò„Åß„ÅôÔºÅ",
                    `${leader.name}„ÄÅÊâãÂøú„Åà„ÅØ„Å©„ÅÜ„ÅãÔºÅÔºü`,
                    "4„Ç≥„Éº„Éä„Éº„ÇíÂõû„Å£„Å¶„ÄÅÁõ¥Á∑ö„Ç≥„Éº„Çπ„Å∏ÔºÅ"
                ];
                msg = phrases[Math.floor(Math.random() * phrases.length)];
            } else if (p > 0.85 && p < 0.9) {
                const phrases = [
                    "„Åï„ÅÇ„ÄÅÊúÄÂæå„ÅÆÁõ¥Á∑öÔºÅ„Åì„Åì„Åã„Çâ„ÅåÂãùË≤†„Å†ÔºÅ",
                    "Áõ¥Á∑ö„Ç≥„Éº„Çπ„Å´Âêë„ÅÑ„ÅüÔºÅÊäú„ÅëÂá∫„Åô„ÅÆ„ÅØË™∞„Å†ÔºÅÔºü",
                    "ÊÆã„Çä200„É°„Éº„Éà„É´ÔºÅÊøÄ„Åó„ÅÑÂè©„ÅçÂêà„ÅÑÔºÅ",
                    "Â§ñ„Åã„Çâ‰∏ÄÊ∞ó„Å´ÂêÑÈ¶¨„ÅåË•≤„ÅÑ„Åã„Åã„ÇãÔºÅ",
                    "ÂÜÖ„Åã„ÇâÈã≠„Åè‰º∏„Å≥„Å¶„Åè„Çã„ÅÆ„ÅØ„Å©„ÅÆÈ¶¨„Å†ÔºÅÔºü"
                ];
                msg = phrases[Math.floor(Math.random() * phrases.length)];
            } else {
                if (leader !== lastLeader && p > 0.2) {
                    const phrases = [
                        `${leader.name} „ÅåÂÖàÈ†≠„Å´Á´ã„Å£„ÅüÔºÅ`,
                        `„Åä„Å£„Å®„ÄÅ„Åì„Åì„Åß ${leader.name} „ÅåÂá∫„ÅüÔºÅ`,
                        `${leader.name}„ÄÅ„Åã„Çè„Åó„ÅüÔºÅÂÖàÈ†≠„ÅåÂ§â„Çè„Çä„Åæ„ÅôÔºÅ`,
                        `${leader.name}„ÄÅ‰∏ÄÊ∞ó„Å´ÂÖàÈ†≠„Å∏Ë∏ä„ÇäÂá∫„ÅüÔºÅ`
                    ];
                    msg = phrases[Math.floor(Math.random() * phrases.length)];
                    lastLeader = leader;
                } else if (Math.random() < 0.2) {
                    const phrases = [
                        `ÂÖàÈ†≠„ÅØ‰æùÁÑ∂„Å®„Åó„Å¶ ${leader.name}ÔºÅ`,
                        `${leader.name} „Åå„É¨„Éº„Çπ„ÇíÂºï„Å£Âºµ„Çä„Åæ„ÅôÔºÅ`,
                        `2Áï™Êâã„Å´„ÅØ ${second.name} „Åå„Å§„Åë„Å¶„ÅÑ„Åæ„Åô„ÄÇ`,
                        `ÂêÑÈ¶¨„ÄÅ‰∏ÄÂõ£„Å®„Å™„Å£„Å¶ÈÄ≤„Çì„Åß„ÅÑ„Åæ„Åô„ÄÇ`,
                        `„Éö„Éº„Çπ„Åå‰∏ä„Åå„Å£„Å¶„Åç„Åæ„Åó„ÅüÔºÅ`,
                        `${second.name}„ÄÅËôéË¶ñÁúà„ÄÖ„Å®„ÉÅ„É£„É≥„Çπ„Çí‰º∫„Å£„Å¶„ÅÑ„Åæ„ÅôÔºÅ`,
                        `„Åæ„Å†ÂêÑÈ¶¨„ÄÅÂãï„Åç„ÅØ„ÅÇ„Çä„Åæ„Åõ„Çì„ÄÇ`
                    ];
                    msg = phrases[Math.floor(Math.random() * phrases.length)];
                }
            }
            if (msg) { announce(msg); lastCommentTime = time; }
        }

        // --- UI & Game Logic ---
        function showCutIn(name, skill, icon) {
            const el = document.getElementById('cut-in-overlay');
            document.getElementById('cut-in-name').innerText = name;
            document.getElementById('cut-in-skill').innerText = skill;
            document.getElementById('cut-in-horse').innerText = icon;
            el.classList.remove('active'); void el.offsetWidth; el.classList.add('active');
            setTimeout(() => el.classList.remove('active'), 1500);
        }

        function announceWinner(winner) {
            const winPhrases = [
                `ÔºëÁùÄ„ÄÅ${winner.name}ÔºÅ Ë¶ã‰∫ã„Å™ÂãùÂà©„Åß„ÅôÔºÅ`,
                `Âãù„Å£„Åü„ÅÆ„ÅØ ${winner.name}ÔºÅ ÂúßÂÄíÁöÑ„Å™Âº∑„Åï„ÇíË¶ã„Åõ„Å§„Åë„Åæ„Åó„ÅüÔºÅ`,
                `${winner.name}„ÄÅ„Ç¥„Éº„É´„Ç§„É≥ÔºÅ Á¥†Êô¥„Çâ„Åó„ÅÑËµ∞„Çä„Åß„Åó„ÅüÔºÅ`,
                `Â§ßÊ≠ìÂ£∞„ÅÆ‰∏≠„ÄÅ${winner.name} „ÅåÂÖàÈ†≠„Åß„Ç¥„Éº„É´„ÇíÈßÜ„ÅëÊäú„Åë„Åæ„Åó„ÅüÔºÅ`
            ];
            const msg = winPhrases[Math.floor(Math.random() * winPhrases.length)];
            announce(msg);
            STATE.winnerAnnounced = true;
        }

        function initGame() {
            document.getElementById('progress-bar').style.width = '80%';
            HORSE_DATA.forEach((data, index) => {
                const h = new Horse(index, data); STATE.horses.push(h);
                const gate = new Gate((index - 2) * CONFIG.laneWidth); STATE.gates.push(gate);
            });
            const selector = document.getElementById('horse-selector');
            HORSE_DATA.forEach((data, index) => {
                const el = document.createElement('div');
                el.className = 'horse-card p-2 pb-8 cursor-pointer flex flex-col items-center relative overflow-hidden';
                el.innerHTML = `<div class="horse-badge">x${(Math.random() * 2 + 1.5).toFixed(1)}</div><div class="w-10 h-10 rounded-full mb-1 border-2 border-white/20 text-xl flex items-center justify-center shadow-inner" style="background:#${data.color.toString(16)}">${data.icon}</div><div class="text-xs font-bold text-gray-200 leading-tight text-center font-tech tracking-wide mb-1">${data.name}</div><div class="skill-badge w-full">${data.skill}</div>`;
                el.dataset.odds = el.querySelector('.horse-badge').innerText.replace('x', '');
                el.onclick = () => selectHorse(index, el);
                selector.appendChild(el);
            });
            setTimeout(() => {
                document.getElementById('loader').style.opacity = 0;
                setTimeout(() => document.getElementById('loader').remove(), 500);
            }, 1000);
            updateCamera(0);
        }

        function selectHorse(index, el) {
            SoundManager.init(); // Initialize audio context on first click
            SoundManager.playClick();
            if (STATE.isRacing) return;
            STATE.selectedHorse = index;
            document.querySelectorAll('.horse-card').forEach(c => c.classList.remove('selected'));
            el.classList.add('selected');
            const btn = document.getElementById('start-btn');
            btn.disabled = false;
            // Remove disabled styling
            btn.classList.remove('cursor-not-allowed', 'opacity-50');
            btn.classList.add('cursor-pointer', 'opacity-100');

            btn.innerHTML = '<span class="block skew-x-[15deg] tracking-[0.2em]">START RACE!</span>';
        }

        function startRace() {
            if (STATE.wallet < STATE.betAmount) { alert("No money!"); return; }
            STATE.wallet -= STATE.betAmount; document.getElementById('wallet-display').innerText = STATE.wallet;
            STATE.isRacing = true; STATE.raceStarted = false;

            // Set random weather for this race
            const randomWeather = WEATHER_TYPES[Math.floor(Math.random() * WEATHER_TYPES.length)];
            applyWeather(randomWeather);

            const bettingPanel = document.getElementById('betting-panel');
            bettingPanel.classList.add('opacity-0', 'pointer-events-none');
            bettingPanel.querySelector('.glass-panel').classList.add('scale-95');

            document.getElementById('camera-btn').classList.remove('hidden');
            document.getElementById('rank-panel').classList.remove('hidden');
            STATE.horses.forEach(h => { h.reset(); h.speed = 0; });
            STATE.gates.forEach(g => g.reset());
            STATE.winnerAnnounced = false; // Reset winner announcement flag
            STATE.cameraMode = 3; updateCamera(0); // Auto Camera Start

            SoundManager.playFanfare();
            announce(`${randomWeather.icon} ${randomWeather.name}„ÄÅÈ¶¨Â†¥Áä∂ÊÖã: ${randomWeather.trackCondition}`);

            const cdOverlay = document.getElementById('countdown-overlay');
            const cdText = document.getElementById('countdown-text');
            cdOverlay.classList.remove('hidden'); cdText.style.opacity = "1";
            let count = 3;

            // Wait for Fanfare (roughly 3s) then start countdown
            setTimeout(() => {
                cdText.innerText = count;
                cdText.className = "text-9xl font-black text-white drop-shadow-lg scale-in";
                SoundManager.playCountdown(3);

                const interval = setInterval(() => {
                    count--;
                    if (count > 0) {
                        cdText.innerText = count; cdText.classList.remove('scale-in'); void cdText.offsetWidth; cdText.classList.add('scale-in');
                        SoundManager.playCountdown(count);
                    } else if (count === 0) {
                        cdText.innerText = "GO!"; cdText.classList.remove('text-white'); cdText.classList.add('text-yellow-400', 'scale-in');
                        SoundManager.playCountdown(0); // GO sound
                        SoundManager.playGate();
                        SoundManager.playAtmosphere(true); // Start crowd/run noise

                        STATE.gates.forEach(g => g.open());
                        announce("„Ç≤„Éº„Éà„ÅåÈñã„ÅÑ„ÅüÔºÅ");
                        setTimeout(() => {
                            STATE.raceStarted = true;
                            STATE.horses.forEach(h => { h.speed = h.baseSpeed * 0.3; });
                        }, 200);
                    } else {
                        clearInterval(interval); cdText.style.opacity = "0";
                        setTimeout(() => { cdOverlay.classList.add('hidden'); cdText.innerText = ""; cdText.style.opacity = "1"; }, 500);
                    }
                }, 1000);
            }, 2500);
        }

        function finishRace(winner) {
            STATE.isRacing = false; STATE.raceStarted = false; STATE.isWinningRun = true;
            const win = (winner.id === STATE.selectedHorse);
            document.getElementById('rank-panel').classList.add('hidden');

            // Winning Run Setup
            confettiManager.start(winner.mesh.position);
            updateCamera(0); // Trigger camera update to switch to winning mode immediately

            if (win) SoundManager.playWin();

            setTimeout(() => {
                const modal = document.getElementById('result-modal'); modal.classList.remove('hidden', 'scale-95', 'opacity-0');
                const msg = document.getElementById('result-message'); const pay = document.getElementById('payout-display');
                if (win) {
                    const cards = document.querySelectorAll('.horse-card'); const odds = parseFloat(cards[STATE.selectedHorse].dataset.odds);
                    const prize = Math.floor(STATE.betAmount * odds); STATE.wallet += prize;
                    msg.innerHTML = `<span class="text-green-600 font-bold">${winner.name}</span> WON!`; pay.innerText = `+${prize} G`;
                    document.getElementById('wallet-display').innerText = STATE.wallet;
                } else {
                    msg.innerHTML = `Winner: <span class="text-gray-800 font-bold">${winner.name}</span>`; pay.innerText = "0 G";
                }
            }, 3000);
        }

        function resetGame() {
            STATE.isWinningRun = false;
            STATE.winner = null;
            confettiManager.stop();
            document.getElementById('result-modal').classList.add('hidden', 'scale-95', 'opacity-0');

            const bettingPanel = document.getElementById('betting-panel');
            bettingPanel.classList.remove('opacity-0', 'pointer-events-none');
            bettingPanel.querySelector('.glass-panel').classList.remove('scale-95');

            document.getElementById('camera-btn').classList.add('hidden');
            STATE.horses.forEach(h => h.reset()); STATE.gates.forEach(g => g.reset()); updateCamera(0);
            document.getElementById('commentary-box').classList.remove('active');
            SoundManager.playAtmosphere(false);
        }

        function toggleCamera() {
            STATE.cameraMode = (STATE.cameraMode + 1) % 4;
            const btn = document.getElementById('camera-btn');
            const icons = ["üì∑", "üöÅ", "‚Üî", "üì∫"];
            btn.innerText = icons[STATE.cameraMode];
        }

        function updateRankingUI() {
            // Sort: Finished horses by rank, then running horses by position
            const sorted = [...STATE.horses].sort((a, b) => {
                if (a.finished && b.finished) return a.finishRank - b.finishRank;
                if (a.finished) return -1;
                if (b.finished) return 1;
                return b.currentT - a.currentT;
            });
            const list = document.getElementById('rank-list'); list.innerHTML = "";
            sorted.forEach((h, i) => {
                const li = document.createElement('li'); li.className = "flex items-center justify-between p-1 rounded bg-white/10";
                const isPlayer = (h.id === STATE.selectedHorse); if (isPlayer) li.classList.add("border", "border-yellow-500/50");
                const rankDisplay = h.finished ? h.finishRank : i + 1;
                const rankClass = h.finished ? 'text-green-400' : (i === 0 ? 'text-yellow-400' : 'text-gray-400');
                li.innerHTML = `<div class="flex items-center gap-2"><span class="w-4 text-center font-bold ${rankClass}">${rankDisplay}</span><div class="w-4 h-4 rounded-full flex items-center justify-center text-[8px]" style="background:#${h.mat.color.getHexString()}">${h.icon}</div><span class="text-xs truncate w-24 ${isPlayer ? 'text-yellow-200' : 'text-gray-300'}">${h.name}</span></div>${h.finished ? '<span class="text-[10px] text-green-400">‚úì</span>' : ''}`;
                list.appendChild(li);
            });
        }

        let lastRankUpdate = 0;

        const clock = new THREE.Clock();
        function updateCamera(time) {
            let leader = STATE.horses[0]; STATE.horses.forEach(h => { if (h.currentT > leader.currentT) leader = h; });
            const leadPos = leader.mesh.position.clone();

            if (STATE.isWinningRun && STATE.winner) {
                // Winning Run Camera - dynamic orbit around winner
                const winner = STATE.winner;
                const leadPos = winner.mesh.position.clone();
                const t = Date.now() * 0.0005;
                const orbitRadius = 15;
                const camX = leadPos.x + Math.cos(t) * orbitRadius;
                const camZ = leadPos.z + Math.sin(t) * orbitRadius;

                camera.position.lerp(new THREE.Vector3(camX, leadPos.y + 5, camZ), 0.05);
                camera.lookAt(leadPos.clone().add(new THREE.Vector3(0, 2, 0)));
            }
            else if (!STATE.isRacing) {
                // Animated camera tour around the track during horse selection
                const t = (Date.now() * 0.00008) % 1.0; // Very slow rotation for elegant presentation
                const tourPoint = STATE.trackCurve.getPointAt(t);
                const tangent = STATE.trackCurve.getTangentAt(t).normalize();
                const normal = new THREE.Vector3(-tangent.z, 0, tangent.x).normalize();

                // Position camera outside the track, looking inward
                const camPos = tourPoint.clone()
                    .add(normal.multiplyScalar(-80)) // Outside the track
                    .add(new THREE.Vector3(0, 60, 0)); // Elevated view

                const lookAt = tourPoint.clone().add(new THREE.Vector3(0, 5, 0));
                camera.position.copy(camPos);
                camera.lookAt(lookAt);
            }
            else {
                // Race Camera Modes
                const t = leader.currentT % 1.0;
                const tan = STATE.trackCurve.getTangentAt(t).normalize();
                const normal = new THREE.Vector3(-tan.z, 0, tan.x).normalize();

                if (STATE.cameraMode === 3) {
                    // --- TV STYLE AUTO CAMERA ---
                    const p = leader.currentT;

                    // Auto Switching Logic (more frequent, random)
                    if (time - STATE.lastAutoSwitch > 2.5) {
                        let nextType;
                        do {
                            nextType = Math.floor(Math.random() * 4);
                        } while (nextType === STATE.autoShotType); // Avoid same shot twice
                        STATE.autoShotType = nextType;
                        STATE.lastAutoSwitch = time;
                    }

                    let targetPos, targetLook;
                    const lerpFactor = 0.05;

                    if (p < 0.1) {
                        // Start: High Rear Wide Shot
                        targetPos = leadPos.clone().sub(tan.multiplyScalar(25)).add(new THREE.Vector3(0, 15, 0));
                        targetLook = leadPos.clone().add(tan.multiplyScalar(20));
                    } else if (p > 0.85) {
                        // Final Stretch: Dynamic Front Zoom
                        targetPos = leadPos.clone().add(tan.multiplyScalar(20)).sub(normal.multiplyScalar(5)).add(new THREE.Vector3(0, 4, 0));
                        targetLook = leadPos.clone().sub(new THREE.Vector3(0, 1, 0));
                    } else {
                        // Mid Race Switching
                        switch (STATE.autoShotType) {
                            case 0: // Dynamic Side-Front
                                targetPos = leadPos.clone().add(normal.multiplyScalar(12)).add(tan.multiplyScalar(8)).add(new THREE.Vector3(0, 6, 0));
                                targetLook = leadPos.clone();
                                break;
                            case 1: // Low Rear Tracking
                                targetPos = leadPos.clone().sub(tan.multiplyScalar(10)).add(new THREE.Vector3(0, 2, 0));
                                targetLook = leadPos.clone().add(new THREE.Vector3(0, 1, 0));
                                break;
                            case 2: // High Bird's Eye
                                targetPos = leadPos.clone().sub(tan.multiplyScalar(5)).add(new THREE.Vector3(0, 50, 0));
                                targetLook = leadPos.clone();
                                break;
                            case 3: // Side Profile Long
                                const sideDist = 25;
                                targetPos = leadPos.clone().add(normal.multiplyScalar(sideDist)).add(new THREE.Vector3(0, 10, 0));
                                targetLook = leadPos.clone();
                                break;
                        }
                    }
                    camera.position.lerp(targetPos, lerpFactor);
                    camera.lookAt(targetLook);

                    // --- CAMERA SHAKE ---
                    if (STATE.cameraShake > 0) {
                        const shakeAmount = STATE.cameraShake;
                        camera.position.x += (Math.random() - 0.5) * shakeAmount;
                        camera.position.y += (Math.random() - 0.5) * shakeAmount;
                        camera.position.z += (Math.random() - 0.5) * shakeAmount;
                        STATE.cameraShake *= 0.9; // Decay
                        if (STATE.cameraShake < 0.01) STATE.cameraShake = 0;
                    }

                } else if (STATE.cameraMode === 0) {
                    // Follow camera
                    const camPos = leadPos.clone().sub(tan.multiplyScalar(40)).add(new THREE.Vector3(0, 25, 0));
                    camera.position.lerp(camPos, 0.1);
                    camera.lookAt(leadPos.clone().add(tan.multiplyScalar(20)));
                } else if (STATE.cameraMode === 1) {
                    // Top camera
                    camera.position.lerp(new THREE.Vector3(0, 120, 120), 0.05);
                    camera.lookAt(leadPos);
                } else {
                    // Side camera
                    const side = new THREE.Vector3(-tan.z, 0, tan.x).normalize().multiplyScalar(10);
                    camera.position.copy(leadPos.clone().add(side).add(new THREE.Vector3(0, 5, 0)));
                    camera.lookAt(leadPos);
                }
            }
        }

        // Initialize Spectators
        spectatorManager = new SpectatorManager(scene);

        function animate() {
            requestAnimationFrame(animate);
            const deltaRaw = clock.getDelta();
            const now = clock.getElapsedTime();

            // --- Time Scale Logic (Photo Finish) ---
            let targetTimeScale = 1.0;
            const leader = STATE.horses.length > 0 ? STATE.horses.reduce((prev, current) => (prev.currentT > current.currentT) ? prev : current) : null;

            if (STATE.isRacing && !STATE.winner && leader) {
                // Slow motion if leader is very close to finish (0.96 to 1.0)
                if (leader.currentT > 0.96 && leader.currentT < 1.0) {
                    targetTimeScale = 0.2; // Slow Motion!
                }
            } else if (STATE.winner) {
                // Restore speed after finish
                targetTimeScale = 1.0;
            }

            // Smooth transition for time scale
            STATE.timeScale += (targetTimeScale - STATE.timeScale) * 0.1;

            // Cap delta to prevent huge jumps if tab was inactive, and apply timeScale
            const delta = Math.min(deltaRaw, 0.1) * STATE.timeScale;

            STATE.gates.forEach(g => g.update(delta));

            // Update Visuals (Pass raw delta or scaled? Spectators might want reliable frames, but slow motion is cool too)
            // Let's make spectators slow down too for consistency
            if (spectatorManager) {
                const leaderP = leader ? leader.currentT : 0;
                spectatorManager.update(now, leaderP);
            }

            if (STATE.isWinningRun && STATE.winner) {
                // Slow forward movement for winner
                const winner = STATE.winner;
                winner.speed = 0.01; // Slow trot
                winner.update(delta); // Animation

                // Keep other horses idle
                STATE.horses.forEach(h => {
                    if (h !== winner) {
                        h.body.position.y = 2 + Math.sin(Date.now() * 0.003 + h.id) * 0.05;
                        h.legs.forEach(l => l.rotation.x = 0); // Ensure others stop running
                    }
                });

                confettiManager.update(delta);
                particleManager.update(delta); // Keep existing particles alive/fading
                updateCamera(now);
                renderer.render(scene, camera);
                return;
            }

            if (STATE.isRacing) {
                particleManager.update(delta); // Update particles
                if (STATE.raceStarted) {
                    let finishedCount = 0;
                    STATE.horses.forEach(h => {
                        if (!h.finished) {
                            h.update(delta);
                            if (h.finished) {
                                // Assign finish rank
                                const finishedHorses = STATE.horses.filter(horse => horse.finished);
                                h.finishRank = finishedHorses.length;
                                if (!STATE.winner) {
                                    STATE.winner = h;
                                    if (!STATE.winnerAnnounced) announceWinner(h);
                                }
                            }
                        } else {
                            finishedCount++;
                        }
                    });
                    if (!STATE.winner) updateCommentary(now);
                    if (now - lastRankUpdate > 0.5) {
                        updateRankingUI();
                        lastRankUpdate = now;
                    }
                    if (STATE.winner && STATE.isRacing && finishedCount === STATE.horses.length) { finishRace(STATE.winner); }
                } else {
                    STATE.horses.forEach(h => { h.body.position.y = 2 + Math.sin(Date.now() * 0.005 + h.id) * 0.02; });
                }
            } else {
                STATE.horses.forEach(h => { h.body.position.y = 2 + Math.sin(Date.now() * 0.003 + h.id) * 0.05; });
            }

            // Animate rain particles
            if (STATE.rainParticles) {
                const positions = STATE.rainParticles.geometry.attributes.position.array;
                for (let i = 0; i < positions.length; i += 3) {
                    positions[i + 1] -= (2 * STATE.timeScale); // Fall down adjusted by timeScale
                    if (positions[i + 1] < 0) {
                        positions[i + 1] = 200; // Reset to top
                    }
                }
                STATE.rainParticles.geometry.attributes.position.needsUpdate = true;
            }

            updateCamera(now); renderer.render(scene, camera);
        }

        initGame(); animate();
        window.addEventListener('resize', () => { camera.aspect = window.innerWidth / window.innerHeight; camera.updateProjectionMatrix(); renderer.setSize(window.innerWidth, window.innerHeight); });
    </script>
</body>

</html>