<!DOCTYPE html>
<html lang="ja">

<head>
    <!--
    ================================================================================
    Toy Derby: Grand Prix - ãƒ¡ã‚¤ãƒ³ HTML
    
    ã“ã®ãƒ•ã‚¡ã‚¤ãƒ«ã¯ã‚²ãƒ¼ãƒ ã®ã™ã¹ã¦ã®æ§‹é€ ã€ã‚¹ã‚¿ã‚¤ãƒ«ã€ãƒ­ã‚¸ãƒƒã‚¯ã‚’å«ã‚“ã§ã„ã¾ã™ã€‚
    Three.jsã‚’ä½¿ç”¨ã—ãŸ3Dæç”»ã¨ã€HTML/CSSã«ã‚ˆã‚‹UIã‚ªãƒ¼ãƒãƒ¼ãƒ¬ã‚¤ã‚’çµ„ã¿åˆã‚ã›ã¦ã„ã¾ã™ã€‚
    ================================================================================
    -->
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Toy Derby: Grand Prix</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.tailwindcss.com"></script>
    <link
        href="https://fonts.googleapis.com/css2?family=Chakra+Petch:wght@400;600;700&family=Orbitron:wght@500;700;900&family=Zen+Kaku+Gothic+New:wght@500;700;900&display=swap"
        rel="stylesheet">
    <script>
        tailwind.config = {
            theme: {
                extend: {
                    fontFamily: {
                        sans: ['"Zen Kaku Gothic New"', 'sans-serif'],
                        display: ['"Orbitron"', 'sans-serif'],
                        tech: ['"Chakra Petch"', 'sans-serif'],
                    },
                    colors: {
                        gold: { 400: '#FBBF24', 500: '#F59E0B', 600: '#D97706', glow: '#FFD700' },
                        glass: {
                            light: 'rgba(255, 255, 255, 0.1)',
                            dark: 'rgba(0, 0, 0, 0.6)',
                            border: 'rgba(255, 255, 255, 0.2)'
                        }
                    }
                }
            }
        }
    </script>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background-color: #1a1a2e;
            font-family: 'Zen Kaku Gothic New', sans-serif;
            color: #e2e8f0;
        }

        /* =========================================
           ãƒ¦ãƒ¼ãƒ†ã‚£ãƒªãƒ†ã‚£ & ãƒ‡ã‚¶ã‚¤ãƒ³ã‚·ã‚¹ãƒ†ãƒ 
           ========================================= */

        /* ã‚°ãƒ©ã‚¹ãƒ¢ãƒ¼ãƒ•ã‚£ã‚ºãƒ  (ã™ã‚Šã‚¬ãƒ©ã‚¹åŠ¹æœ) ã®å…±é€šã‚¯ãƒ©ã‚¹ */
        .glass-panel {
            background: rgba(15, 23, 42, 0.65);
            backdrop-filter: blur(12px);
            -webkit-backdrop-filter: blur(12px);
            border: 1px solid rgba(255, 255, 255, 0.1);
            box-shadow: 0 8px 32px 0 rgba(0, 0, 0, 0.37);
        }

        .glass-header {
            background: linear-gradient(180deg, rgba(0, 0, 0, 0.8) 0%, rgba(0, 0, 0, 0) 100%);
            padding-bottom: 2rem;
        }

        /* é¦¬é¸æŠã‚«ãƒ¼ãƒ‰ã®ã‚¹ã‚¿ã‚¤ãƒ« */
        .horse-card {
            background: linear-gradient(145deg, rgba(30, 41, 59, 0.9), rgba(15, 23, 42, 0.95));
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: 12px;
            box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.5);
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            position: relative;
            overflow: hidden;
        }

        .horse-card::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: linear-gradient(45deg, transparent 40%, rgba(255, 255, 255, 0.05) 45%, transparent 50%);
            z-index: 1;
            transform: translateX(-100%);
            transition: transform 0.6s;
        }

        .horse-card:hover::before {
            transform: translateX(100%);
        }

        .horse-card:hover {
            transform: translateY(-5px) scale(1.02);
            border-color: rgba(251, 191, 36, 0.5);
            box-shadow: 0 10px 25px -5px rgba(251, 191, 36, 0.15);
        }

        .horse-card.selected {
            border: 2px solid #F59E0B;
            background: linear-gradient(145deg, rgba(50, 40, 20, 0.95), rgba(30, 25, 10, 0.95));
            box-shadow: 0 0 20px rgba(245, 158, 11, 0.4);
            transform: scale(1.05);
            z-index: 10;
        }

        .horse-badge {
            position: absolute;
            top: 0;
            right: 0;
            background: linear-gradient(135deg, #F59E0B, #D97706);
            color: #fff;
            font-family: 'Orbitron', sans-serif;
            font-weight: 700;
            font-size: 0.8rem;
            padding: 4px 8px;
            border-bottom-left-radius: 8px;
            box-shadow: -2px 2px 5px rgba(0, 0, 0, 0.3);
            z-index: 5;
        }

        .skill-badge {
            position: absolute;
            bottom: 0;
            left: 0;
            right: 0;
            background: rgba(0, 0, 0, 0.8);
            border-top: 1px solid rgba(255, 255, 255, 0.1);
            color: #94a3b8;
            font-family: 'Chakra Petch', sans-serif;
            font-size: 0.65rem;
            text-align: center;
            padding: 4px;
            text-transform: uppercase;
            letter-spacing: 0.05em;
        }

        .horse-card.selected .skill-badge {
            color: #FCD34D;
            background: rgba(40, 20, 0, 0.8);
        }

        /* ãƒã‚ªãƒ³é¢¨ãƒœã‚¿ãƒ³ã®ã‚¨ãƒ•ã‚§ã‚¯ãƒˆ */
        .btn-neon {
            background: linear-gradient(90deg, #F59E0B, #ea580c);
            color: white;
            text-shadow: 0 2px 4px rgba(0, 0, 0, 0.3);
            position: relative;
            overflow: hidden;
            transition: all 0.3s;
            font-family: 'Orbitron', sans-serif;
            letter-spacing: 0.05em;
            border: 1px solid rgba(255, 255, 255, 0.2);
        }

        .btn-neon:hover:not(:disabled) {
            transform: translateY(-2px);
            box-shadow: 0 0 20px rgba(245, 158, 11, 0.6);
            filter: brightness(1.2);
        }

        .btn-neon:active:not(:disabled) {
            transform: translateY(1px);
        }

        .btn-neon:disabled {
            background: #334155;
            color: #94a3b8;
            cursor: not-allowed;
            border-color: transparent;
        }

        /* =========================================
           ã‚²ãƒ¼ãƒ UIãƒ¬ã‚¤ã‚¢ã‚¦ãƒˆ
           Three.jsã®ã‚­ãƒ£ãƒ³ãƒã‚¹ã®ä¸Šã«é‡ã­ã‚‹è¦ç´ ç¾¤
           ========================================= */
        #game-ui {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            display: flex;
            flex-direction: column;
            justify-content: space-between;
            overflow: hidden;
        }

        .interactive {
            pointer-events: auto;
        }

        #betting-panel {
            background: transparent;
        }

        /* Loader */
        #loader {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: #0f172a;
            color: white;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 50;
            transition: opacity 0.5s;
        }

        .loading-bar {
            width: 240px;
            height: 6px;
            background: #1e293b;
            margin-top: 15px;
            border-radius: 3px;
            overflow: hidden;
            box-shadow: inset 0 1px 3px rgba(0, 0, 0, 0.5);
        }

        .loading-progress {
            height: 100%;
            background: linear-gradient(90deg, #F59E0B, #FCD34D);
            width: 0%;
            transition: width 0.2s;
            box-shadow: 0 0 10px rgba(245, 158, 11, 0.5);
        }

        /* Rank Panel */
        #rank-panel ul li {
            font-family: 'Chakra Petch', sans-serif;
            transition: all 0.2s;
        }

        /* Cut-in */
        #cut-in-overlay {
            position: absolute;
            top: 25%;
            left: -100%;
            width: 100%;
            height: 240px;
            display: flex;
            align-items: center;
            background: linear-gradient(90deg, rgba(0, 0, 0, 0) 0%, rgba(245, 158, 11, 0.8) 15%, rgba(234, 88, 12, 0.9) 50%, rgba(245, 158, 11, 0.8) 85%, rgba(0, 0, 0, 0) 100%);
            z-index: 40;
            transform: skewX(-15deg);
            transition: left 0.4s cubic-bezier(0.2, 0.8, 0.2, 1);
            pointer-events: none;
            opacity: 0;
            backdrop-filter: blur(4px);
            border-top: 2px solid rgba(255, 255, 255, 0.4);
            border-bottom: 2px solid rgba(255, 255, 255, 0.4);
        }

        #cut-in-overlay.active {
            left: -10%;
            opacity: 1;
        }

        .cut-in-content {
            transform: skewX(15deg);
            display: flex;
            align-items: center;
            width: 100%;
            justify-content: center;
            color: white;
            text-shadow: 4px 4px 0 rgba(0, 0, 0, 0.5);
        }

        .cut-in-text {
            font-family: 'Orbitron', sans-serif;
            font-size: 3.5rem;
            font-weight: 900;
            font-style: italic;
            margin-left: 30px;
            text-transform: uppercase;
            background: linear-gradient(to bottom, #fff, #FCD34D);
            -webkit-background-clip: text;
            background-clip: text;
            -webkit-text-fill-color: transparent;
            filter: drop-shadow(0 4px 4px rgba(0, 0, 0, 0.5));
        }

        .cut-in-horse-name {
            font-size: 1.5rem;
            margin-bottom: -10px;
            opacity: 0.95;
            letter-spacing: 0.1em;
        }

        /* Commentary Box */
        #commentary-box {
            position: absolute;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%) translateY(100px);
            width: 90%;
            max-width: 800px;
            background: linear-gradient(to right, rgba(0, 0, 0, 0), rgba(0, 0, 0, 0.8) 20%, rgba(0, 0, 0, 0.8) 80%, rgba(0, 0, 0, 0));
            padding: 1rem 3rem;
            border-radius: 0;
            text-align: center;
            color: #4ade80;
            /* Neon Green */
            font-family: 'Zen Kaku Gothic New', sans-serif;
            font-weight: 700;
            font-size: 1.4rem;
            opacity: 0;
            transition: all 0.3s;
            text-shadow: 0 0 10px rgba(74, 222, 128, 0.5);
            pointer-events: none;
            border-top: 1px solid rgba(74, 222, 128, 0.3);
            border-bottom: 1px solid rgba(74, 222, 128, 0.3);
        }

        #commentary-box.active {
            opacity: 1;
            transform: translateX(-50%) translateY(0);
        }

        /* Countdown */
        .scale-in {
            animation: scaleIn 0.4s cubic-bezier(0.175, 0.885, 0.32, 1.275);
        }

        @keyframes scaleIn {
            0% {
                transform: scale(0);
                opacity: 0;
            }

            60% {
                transform: scale(1.2);
            }

            100% {
                transform: scale(1);
                opacity: 1;
            }
        }

        .speed-lines {
            position: absolute;
            inset: 0;
            background: repeating-linear-gradient(90deg, transparent 0, transparent 20px, rgba(255, 255, 255, 0.2) 21px, transparent 22px);
            animation: speedLines 0.1s linear infinite;
            pointer-events: none;
            opacity: 0;
            transition: opacity 0.3s;
        }

        .speed-lines.active {
            opacity: 0.3;
        }

        @keyframes speedLines {
            from {
                transform: translateX(0);
            }

            to {
                transform: translateX(-20px);
            }
        }

        /* Countdown */
        #countdown-text {
            text-shadow: 4px 4px 0px #000, 0 0 20px rgba(255, 255, 0, 0.5);
            transition: opacity 0.5s;
        }

        .scale-in {
            animation: scaleIn 0.5s cubic-bezier(0.175, 0.885, 0.32, 1.275) forwards;
        }

        @keyframes scaleIn {
            0% {
                transform: scale(0);
                opacity: 0;
            }

            80% {
                transform: scale(1.2);
                opacity: 1;
            }

            100% {
                transform: scale(1.0);
                opacity: 1;
            }
        }

        /* Rank Panel */
        #rank-panel {
            transition: opacity 0.3s;
        }

        .rank-row {
            transition: top 0.3s ease-out;
        }

        /* Commentary Box */
        #commentary-box {
            position: absolute;
            bottom: 120px;
            left: 50%;
            transform: translateX(-50%);
            width: 90%;
            max-width: 600px;
            background: rgba(0, 0, 0, 0.7);
            border: 2px solid rgba(255, 255, 255, 0.3);
            border-radius: 8px;
            padding: 10px 20px;
            color: white;
            text-align: center;
            font-weight: bold;
            font-size: 1.1rem;
            text-shadow: 1px 1px 2px black;
            opacity: 0;
            transition: opacity 0.5s;
            z-index: 30;
            pointer-events: none;
        }

        #commentary-box.active {
            opacity: 1;
        }

        .commentary-label {
            display: inline-block;
            background: #D32F2F;
            color: white;
            padding: 2px 8px;
            font-size: 0.7rem;
            border-radius: 4px;
            margin-right: 8px;
            vertical-align: middle;
        }

        #sound-toggle {
            position: absolute;
            top: 80px;
            right: 20px;
            background: rgba(0, 0, 0, 0.5);
            color: white;
            padding: 8px;
            border-radius: 50%;
            width: 40px;
            height: 40px;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            pointer-events: auto;
            z-index: 60;
        }
    </style>
</head>

<body>

    <!-- Loading Screen -->
    <div id="loader">
        <div class="text-3xl font-bold mb-2">Toy Derby GP</div>
        <div class="text-sm text-gray-400">Building Racecourse...</div>
        <div class="loading-bar">
            <div class="loading-progress" id="progress-bar"></div>
        </div>
    </div>

    <!-- UI Overlay -->
    <div id="game-ui">
        <!-- Sound Toggle -->
        <div id="sound-toggle" onclick="toggleMute()">ğŸ”Š</div>

        <!-- Countdown Overlay -->
        <div id="countdown-overlay"
            class="absolute inset-0 flex items-center justify-center z-50 pointer-events-none hidden">
            <div id="countdown-text" class="text-9xl font-black text-yellow-400 italic">3</div>
        </div>

        <!-- Rank Panel (Top Right) -->
        <div id="rank-panel"
            class="hidden absolute top-20 right-4 bg-black/60 backdrop-blur-md p-3 rounded-xl text-white w-56 z-20 border border-white/10 shadow-xl">
            <div class="flex justify-between items-center mb-2 border-b border-white/20 pb-1">
                <h3 class="text-xs font-bold text-gray-300 uppercase tracking-wider">Live Ranking</h3>
                <div class="w-2 h-2 rounded-full bg-red-500 animate-pulse"></div>
            </div>
            <ul id="rank-list" class="space-y-1"></ul>
        </div>

        <!-- Commentary Box -->
        <div id="commentary-box">
            <span class="commentary-label">LIVE</span>
            <span id="commentary-text">ãƒ¬ãƒ¼ã‚¹é–‹å§‹ã‚’å¾…ã£ã¦ã„ã¾ã™...</span>
        </div>

        <!-- Cut-in Overlay -->
        <div id="cut-in-overlay">
            <div class="speed-lines"></div>
            <div class="cut-in-content">
                <div id="cut-in-horse" class="text-6xl">ğŸ´</div>
                <div class="flex flex-col">
                    <span id="cut-in-name" class="cut-in-horse-name">Horse Name</span>
                    <span id="cut-in-skill" class="cut-in-text">SKILL NAME!</span>
                </div>
            </div>
        </div>

        <!-- Header -->
        <div class="p-6 flex justify-between items-start glass-header w-full absolute top-0 z-10 pointer-events-none">
            <div class="glass-panel px-6 py-3 rounded-lg flex items-center gap-4 transform skew-x-[-10deg]">
                <h1 class="text-2xl font-tech font-bold text-white italic tracking-wider skew-x-[10deg]">
                    TOY DERBY <span class="text-gold-500 text-sm">GP</span>
                </h1>
                <div class="h-6 w-px bg-white/20 skew-x-[10deg]"></div>
                <div id="course-name-display"
                    class="text-sm font-display text-white skew-x-[10deg] tracking-wide text-shadow-sm uppercase">
                    LOADING</div>
                <div class="h-6 w-px bg-white/20 skew-x-[10deg]"></div>
                <div class="flex items-center gap-2 skew-x-[10deg]">
                    <div class="text-gold-400 text-xs">CREDITS</div>
                    <span id="wallet-display"
                        class="font-display font-bold text-gold-glow text-2xl tracking-widest text-shadow-glow">1000</span>
                    <span class="text-xs text-gray-400">G</span>
                </div>
            </div>

            <button id="camera-btn"
                class="interactive hidden btn-neon rounded-lg w-12 h-12 flex items-center justify-center text-xl shadow-lg"
                onclick="toggleCamera()">
                ï¿½
            </button>
        </div>

        <!-- Speed Lines Overlay -->
        <div id="speed-lines" class="speed-lines"></div>

        <!-- Center: Results -->
        <div id="center-panel" class="absolute inset-0 flex items-center justify-center pointer-events-none z-30">
            <div id="result-modal"
                class="hidden interactive glass-panel border border-gold-500/30 p-8 rounded-xl shadow-xl max-w-sm w-full text-center transform scale-95 opacity-0 transition-all duration-300">
                <div class="text-6xl mb-4 filter drop-shadow-[0_0_10px_rgba(255,255,255,0.5)]">ğŸ</div>
                <h2 class="text-4xl font-display font-bold mb-2 text-white italic tracking-tighter">FINISH!</h2>
                <div id="result-message" class="text-lg mb-6 font-tech text-gray-300 tracking-wide">...</div>

                <div class="bg-black/40 rounded-lg p-4 mb-8 border border-white/5">
                    <div class="text-xs text-gray-500 uppercase font-bold tracking-widest mb-1">TOTAL PAYOUT</div>
                    <div id="payout-display" class="text-5xl font-display font-bold text-gold-glow drop-shadow-md">0 G
                    </div>
                </div>

                <button onclick="resetGame()"
                    class="w-full btn-neon py-4 text-xl font-bold rounded shadow-lg transition transform hover:scale-[1.02] tracking-wider">
                    NEXT RACE
                </button>
            </div>
        </div>

        <!-- Footer: Betting -->
        <div id="betting-panel"
            class="interactive absolute inset-0 flex items-center justify-center z-20 transition-all duration-500 ease-in-out bg-black/50 backdrop-blur-sm">
            <div
                class="glass-panel p-8 rounded-xl shadow-2xl max-w-6xl w-full mx-4 transform transition-all duration-500">
                <div class="flex justify-between items-center mb-6 border-b border-white/10 pb-4">
                    <h3 class="text-white font-tech font-bold text-3xl tracking-widest border-l-4 border-gold-500 pl-4">
                        SELECT HORSE</h3>
                    <div
                        class="bg-black/40 px-6 py-2 rounded-lg text-sm text-gray-300 font-tech flex items-center gap-3 border border-white/5">
                        <span>BET AMOUNT</span>
                        <span class="font-display font-bold text-gold-400 text-2xl">100 G</span>
                    </div>
                </div>

                <div class="grid grid-cols-5 gap-4" id="horse-selector">
                    <!-- Cards generated by JS -->
                </div>

                <div class="mt-8 flex justify-center">
                    <button id="start-btn" onclick="startRace()" disabled
                        class="btn-neon py-4 px-24 text-2xl font-bold rounded skew-x-[-15deg] shadow-[0_0_30px_rgba(245,158,11,0.3)] opacity-50 cursor-not-allowed transition-all hover:scale-105 active:scale-95">
                        <span class="block skew-x-[15deg] tracking-[0.2em]">START RACE</span>
                    </button>
                </div>
            </div>
        </div>
    </div>

    <script>
        /*
        ================================================================================
        JavaScript ã‚²ãƒ¼ãƒ ãƒ­ã‚¸ãƒƒã‚¯
        ================================================================================
        */

        // ================================================================================
        // ã‚µã‚¦ãƒ³ãƒ‰ç®¡ç†ã‚·ã‚¹ãƒ†ãƒ  (Web Audio API)
        // ================================================================================
        // ã‚²ãƒ¼ãƒ å†…ã®å…¨ã¦ã®éŸ³éŸ¿åŠ¹æœã‚’ç®¡ç†ã™ã‚‹ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆ
        // - BGMã€åŠ¹æœéŸ³ã€å®Ÿæ³éŸ³å£°ã®å†ç”Ÿã‚’åˆ¶å¾¡
        // - Web Audio APIã‚’ä½¿ç”¨ã—ã¦ãƒ—ãƒ­ã‚·ãƒ¼ã‚¸ãƒ£ãƒ«ãªéŸ³ã‚’ç”Ÿæˆ
        // - Speech Synthesis APIã§å®Ÿæ³ãƒ†ã‚­ã‚¹ãƒˆã‚’èª­ã¿ä¸Šã’
        const SoundManager = {
            // Web Audio APIã®ã‚³ãƒ³ãƒ†ã‚­ã‚¹ãƒˆ(éŸ³å£°å‡¦ç†ã®ä¸­æ ¸)
            ctx: null,
            // ãƒŸãƒ¥ãƒ¼ãƒˆçŠ¶æ…‹ãƒ•ãƒ©ã‚°
            isMuted: false,

            /**
             * ã‚ªãƒ¼ãƒ‡ã‚£ã‚ªã‚³ãƒ³ãƒ†ã‚­ã‚¹ãƒˆã®åˆæœŸåŒ–
             * ãƒ¦ãƒ¼ã‚¶ãƒ¼ã‚¤ãƒ³ã‚¿ãƒ©ã‚¯ã‚·ãƒ§ãƒ³å¾Œã«å‘¼ã³å‡ºã™å¿…è¦ãŒã‚ã‚‹(ãƒ–ãƒ©ã‚¦ã‚¶ã®ãƒãƒªã‚·ãƒ¼)
             */
            init: function () {
                // ã‚³ãƒ³ãƒ†ã‚­ã‚¹ãƒˆãŒæœªä½œæˆã®å ´åˆã¯æ–°è¦ä½œæˆ
                if (!this.ctx) {
                    const AudioContext = window.AudioContext || window.webkitAudioContext;
                    this.ctx = new AudioContext();
                }
                // ã‚µã‚¹ãƒšãƒ³ãƒ‰çŠ¶æ…‹ã®å ´åˆã¯å†é–‹(ãƒ–ãƒ©ã‚¦ã‚¶ã®è‡ªå‹•å†ç”Ÿãƒãƒªã‚·ãƒ¼å¯¾ç­–)
                if (this.ctx.state === 'suspended') {
                    this.ctx.resume();
                }
            },

            /**
             * ã‚ªã‚·ãƒ¬ãƒ¼ã‚¿ãƒ¼(ç™ºæŒ¯å™¨)ã‚’ä½¿ç”¨ã—ã¦éŸ³ã‚’ç”Ÿæˆãƒ»å†ç”Ÿ
             * @param {string} type - æ³¢å½¢ã‚¿ã‚¤ãƒ— ('sine', 'square', 'triangle', 'sawtooth')
             * @param {number} freq - å‘¨æ³¢æ•°(Hz)
             * @param {number} duration - æŒç¶šæ™‚é–“(ç§’)
             * @param {number} startTime - é–‹å§‹é…å»¶æ™‚é–“(ç§’)
             * @param {number} vol - éŸ³é‡(0.0-1.0)
             */
            playOscillator: function (type, freq, duration, startTime = 0, vol = 0.1) {
                if (!this.ctx || this.isMuted) return;
                // ã‚ªã‚·ãƒ¬ãƒ¼ã‚¿ãƒ¼ãƒãƒ¼ãƒ‰(éŸ³æº)ã‚’ä½œæˆ
                const osc = this.ctx.createOscillator();
                // ã‚²ã‚¤ãƒ³ãƒãƒ¼ãƒ‰(éŸ³é‡èª¿æ•´)ã‚’ä½œæˆ
                const gain = this.ctx.createGain();
                // æ³¢å½¢ã‚¿ã‚¤ãƒ—ã‚’è¨­å®š
                osc.type = type;
                // å‘¨æ³¢æ•°ã‚’è¨­å®š
                osc.frequency.setValueAtTime(freq, this.ctx.currentTime + startTime);
                // åˆæœŸéŸ³é‡ã‚’è¨­å®š
                gain.gain.setValueAtTime(vol, this.ctx.currentTime + startTime);
                // éŸ³é‡ã‚’å¾ã€…ã«æ¸›è¡°ã•ã›ã‚‹(ãƒ•ã‚§ãƒ¼ãƒ‰ã‚¢ã‚¦ãƒˆåŠ¹æœ)
                gain.gain.exponentialRampToValueAtTime(0.01, this.ctx.currentTime + startTime + duration);
                // ã‚ªã‚·ãƒ¬ãƒ¼ã‚¿ãƒ¼ã‚’ã‚²ã‚¤ãƒ³ã«æ¥ç¶š
                osc.connect(gain);
                // ã‚²ã‚¤ãƒ³ã‚’ã‚¹ãƒ”ãƒ¼ã‚«ãƒ¼å‡ºåŠ›ã«æ¥ç¶š
                gain.connect(this.ctx.destination);
                // éŸ³ã®å†ç”Ÿé–‹å§‹
                osc.start(this.ctx.currentTime + startTime);
                // éŸ³ã®å†ç”Ÿåœæ­¢
                osc.stop(this.ctx.currentTime + startTime + duration);
            },

            /**
             * UIã‚¯ãƒªãƒƒã‚¯éŸ³ã‚’å†ç”Ÿ
             * 800Hzã®ã‚µã‚¤ãƒ³æ³¢ã§çŸ­ã„ã€Œãƒ”ãƒƒã€ã¨ã„ã†éŸ³
             */
            playClick: function () {
                this.playOscillator('sine', 800, 0.1, 0, 0.1);
            },

            /**
             * ã‚«ã‚¦ãƒ³ãƒˆãƒ€ã‚¦ãƒ³éŸ³ã‚’å†ç”Ÿ
             * @param {number} count - ã‚«ã‚¦ãƒ³ãƒˆæ•°(0ã§GO!éŸ³)
             */
            playCountdown: function (count) {
                if (count > 0) {
                    // 3, 2, 1ã®ã‚«ã‚¦ãƒ³ãƒˆéŸ³(600Hzã®çŸ©å½¢æ³¢)
                    this.playOscillator('square', 600, 0.15, 0, 0.1);
                } else {
                    // GO!ã®éŸ³(1200Hzã®çŸ©å½¢æ³¢ã€ã‚ˆã‚Šé«˜ãé•·ã„)
                    this.playOscillator('square', 1200, 0.4, 0, 0.1);
                }
            },

            /**
             * ã‚¹ã‚¿ãƒ¼ãƒˆã‚²ãƒ¼ãƒˆé–‹æ”¾éŸ³ã‚’å†ç”Ÿ
             * ãƒ›ãƒ¯ã‚¤ãƒˆãƒã‚¤ã‚ºã‚’ãƒ­ãƒ¼ãƒ‘ã‚¹ãƒ•ã‚£ãƒ«ã‚¿ãƒ¼ã§åŠ å·¥ã—ã¦é‡åšãªéŸ³ã‚’ç”Ÿæˆ
             */
            playGate: function () {
                if (!this.ctx || this.isMuted) return;
                // ãƒã‚¤ã‚ºãƒãƒƒãƒ•ã‚¡ã‚’ä½œæˆ(0.5ç§’åˆ†)
                const bufferSize = this.ctx.sampleRate * 0.5;
                const buffer = this.ctx.createBuffer(1, bufferSize, this.ctx.sampleRate);
                const data = buffer.getChannelData(0);
                // ãƒ›ãƒ¯ã‚¤ãƒˆãƒã‚¤ã‚ºã‚’ç”Ÿæˆ(ãƒ©ãƒ³ãƒ€ãƒ ãªå€¤)
                for (let i = 0; i < bufferSize; i++) {
                    data[i] = Math.random() * 2 - 1;
                }
                // ãƒãƒƒãƒ•ã‚¡ã‚½ãƒ¼ã‚¹ãƒãƒ¼ãƒ‰ã‚’ä½œæˆ
                const noise = this.ctx.createBufferSource();
                noise.buffer = buffer;
                const gain = this.ctx.createGain();

                // ãƒ­ãƒ¼ãƒ‘ã‚¹ãƒ•ã‚£ãƒ«ã‚¿ãƒ¼(é«˜å‘¨æ³¢ã‚’ã‚«ãƒƒãƒˆ)ã§é‡åšãªéŸ³ã«åŠ å·¥
                const filter = this.ctx.createBiquadFilter();
                filter.type = 'lowpass';
                filter.frequency.value = 500; // 500Hzä»¥ä¸‹ã®å‘¨æ³¢æ•°ã®ã¿é€šé

                // éŸ³é‡ã‚’è¨­å®šã—ã€å¾ã€…ã«æ¸›è¡°
                gain.gain.setValueAtTime(0.3, this.ctx.currentTime);
                gain.gain.exponentialRampToValueAtTime(0.01, this.ctx.currentTime + 0.3);

                // ãƒãƒ¼ãƒ‰æ¥ç¶š: ãƒã‚¤ã‚º â†’ ãƒ•ã‚£ãƒ«ã‚¿ãƒ¼ â†’ ã‚²ã‚¤ãƒ³ â†’ å‡ºåŠ›
                noise.connect(filter);
                filter.connect(gain);
                gain.connect(this.ctx.destination);
                noise.start();
            },

            /**
             * ãƒ•ã‚¡ãƒ³ãƒ•ã‚¡ãƒ¼ãƒ¬éŸ³ã‚’å†ç”Ÿ
             * ã‚¢ãƒ«ãƒšã‚¸ã‚ª(åˆ†æ•£å’ŒéŸ³)ã§C-E-G-Cã®ãƒ¡ãƒ­ãƒ‡ã‚£ãƒ¼ã‚’æ¼”å¥
             */
            playFanfare: function () {
                if (!this.ctx || this.isMuted) return;
                // Cãƒ¡ã‚¸ãƒ£ãƒ¼ã‚³ãƒ¼ãƒ‰ã®éŸ³éš(ãƒ‰ãƒ»ãƒŸãƒ»ã‚½ãƒ»ãƒ‰)
                const now = this.ctx.currentTime;
                const notes = [523.25, 659.25, 783.99, 1046.50]; // C, E, G, C
                // å„éŸ³ã‚’0.15ç§’é–“éš”ã§é †æ¬¡å†ç”Ÿ
                notes.forEach((freq, i) => {
                    this.playOscillator('triangle', freq, 0.3, i * 0.15, 0.15);
                });
                // æœ€å¾Œã®é«˜ã„Cã‚’é•·ã‚ã«å†ç”Ÿ
                this.playOscillator('triangle', 1046.50, 0.8, 0.6, 0.15);
            },

            /**
             * ã‚¹ã‚­ãƒ«ç™ºå‹•éŸ³ã‚’å†ç”Ÿ
             * å‘¨æ³¢æ•°ãŒä¸Šæ˜‡ã™ã‚‹åŠ¹æœéŸ³(400Hz â†’ 1200Hz)
             */
            playSkill: function () {
                if (!this.ctx || this.isMuted) return;
                const osc = this.ctx.createOscillator();
                const gain = this.ctx.createGain();
                // é–‹å§‹å‘¨æ³¢æ•°ã‚’è¨­å®š
                osc.frequency.setValueAtTime(400, this.ctx.currentTime);
                // 0.5ç§’ã‹ã‘ã¦å‘¨æ³¢æ•°ã‚’ä¸Šæ˜‡(ãƒ”ãƒƒãƒãƒ™ãƒ³ãƒ‰åŠ¹æœ)
                osc.frequency.linearRampToValueAtTime(1200, this.ctx.currentTime + 0.5);
                // éŸ³é‡ã‚’è¨­å®šã—ã€å¾ã€…ã«æ¸›è¡°
                gain.gain.setValueAtTime(0.1, this.ctx.currentTime);
                gain.gain.linearRampToValueAtTime(0, this.ctx.currentTime + 0.5);
                osc.connect(gain);
                gain.connect(this.ctx.destination);
                osc.start();
                osc.stop(this.ctx.currentTime + 0.5);
            },

            /**
             * å‹åˆ©éŸ³ã‚’å†ç”Ÿ
             * ãƒ¡ã‚¸ãƒ£ãƒ¼ã‚³ãƒ¼ãƒ‰(C-E-G)ã‚’åŒæ™‚ã«é³´ã‚‰ã—ã¦è¯ã‚„ã‹ãªéŸ³ã‚’ç”Ÿæˆ
             */
            playWin: function () {
                if (!this.ctx || this.isMuted) return;
                // Cãƒ¡ã‚¸ãƒ£ãƒ¼ã‚³ãƒ¼ãƒ‰ã®æ§‹æˆéŸ³
                const now = this.ctx.currentTime;
                [523.25, 659.25, 783.99].forEach(f => {
                    const osc = this.ctx.createOscillator();
                    const gain = this.ctx.createGain();
                    osc.type = 'triangle'; // ä¸‰è§’æ³¢ã§æŸ”ã‚‰ã‹ã„éŸ³è‰²
                    osc.frequency.value = f;
                    gain.gain.setValueAtTime(0.1, now);
                    gain.gain.exponentialRampToValueAtTime(0.01, now + 1.0);
                    osc.connect(gain);
                    gain.connect(this.ctx.destination);
                    osc.start(now);
                    osc.stop(now + 1.0);
                });
            },

            // ç’°å¢ƒéŸ³ç”¨ã®ãƒãƒ¼ãƒ‰ã¨ãƒ•ã‚£ãƒ«ã‚¿ãƒ¼çŠ¶æ…‹
            noiseNode: null,
            lastOut: 0,

            /**
             * ç’°å¢ƒéŸ³(è¦³å®¢ã®æ­“å£°ãƒ»é¦¬ã®è¹„ã®éŸ³)ã‚’ãƒ«ãƒ¼ãƒ—å†ç”Ÿ
             * @param {boolean} active - true:å†ç”Ÿé–‹å§‹, false:åœæ­¢
             */
            playAtmosphere: function (active) {
                if (!this.ctx || this.isMuted) return;
                if (active) {
                    // æ—¢ã«å†ç”Ÿä¸­ã®å ´åˆã¯ä½•ã‚‚ã—ãªã„
                    if (this.noiseNode) return;
                    // ãƒ”ãƒ³ã‚¯ãƒã‚¤ã‚ºé¢¨ã®éŸ³ã‚’ç”Ÿæˆ(ãƒ›ãƒ¯ã‚¤ãƒˆãƒã‚¤ã‚ºã‚ˆã‚Šä½å‘¨æ³¢ãŒå¼·èª¿)
                    const bufferSize = this.ctx.sampleRate * 2;
                    const buffer = this.ctx.createBuffer(1, bufferSize, this.ctx.sampleRate);
                    const data = buffer.getChannelData(0);
                    // ãƒ­ãƒ¼ãƒ‘ã‚¹ãƒ•ã‚£ãƒ«ã‚¿ãƒ¼åŠ¹æœã‚’æŒã¤ãƒã‚¤ã‚ºç”Ÿæˆ
                    for (let i = 0; i < bufferSize; i++) {
                        const white = Math.random() * 2 - 1;
                        // å‰ã®å€¤ã¨æ··ãœã‚‹ã“ã¨ã§ä½å‘¨æ³¢ã‚’å¼·èª¿
                        data[i] = (this.lastOut + (0.02 * white)) / 1.02;
                        this.lastOut = data[i];
                        data[i] *= 3.5; // éŸ³é‡ã‚’å¢—å¹…
                    }
                    this.noiseNode = this.ctx.createBufferSource();
                    this.noiseNode.buffer = buffer;
                    this.noiseNode.loop = true; // ãƒ«ãƒ¼ãƒ—å†ç”Ÿã‚’æœ‰åŠ¹åŒ–

                    // éŸ³é‡èª¿æ•´
                    const gain = this.ctx.createGain();
                    gain.gain.value = 0.05; // æ§ãˆã‚ãªéŸ³é‡

                    // ãƒ­ãƒ¼ãƒ‘ã‚¹ãƒ•ã‚£ãƒ«ã‚¿ãƒ¼ã§é«˜å‘¨æ³¢ã‚’ã‚«ãƒƒãƒˆ(ã“ã‚‚ã£ãŸéŸ³ã«)
                    const filter = this.ctx.createBiquadFilter();
                    filter.type = 'lowpass';
                    filter.frequency.value = 400;

                    // ãƒãƒ¼ãƒ‰æ¥ç¶š
                    this.noiseNode.connect(filter);
                    filter.connect(gain);
                    gain.connect(this.ctx.destination);
                    this.noiseNode.start();
                    this.bgGain = gain;
                } else {
                    // ç’°å¢ƒéŸ³ã‚’åœæ­¢
                    if (this.noiseNode) {
                        this.noiseNode.stop();
                        this.noiseNode = null;
                        this.lastOut = 0;
                    }
                }
            },

            /**
             * ãƒ†ã‚­ã‚¹ãƒˆã‚’éŸ³å£°ã§èª­ã¿ä¸Šã’(å®Ÿæ³)
             * @param {string} text - èª­ã¿ä¸Šã’ã‚‹ãƒ†ã‚­ã‚¹ãƒˆ
             */
            speak: function (text) {
                if (this.isMuted) return;
                if (!window.speechSynthesis) return;

                // ç¾åœ¨å†ç”Ÿä¸­ã®éŸ³å£°ã‚’ã‚­ãƒ£ãƒ³ã‚»ãƒ«(æ–°ã—ã„å®Ÿæ³ã‚’å„ªå…ˆ)
                window.speechSynthesis.cancel();

                // éŸ³å£°åˆæˆã®è¨­å®š
                const utterance = new SpeechSynthesisUtterance(text);
                utterance.lang = 'ja-JP'; // æ—¥æœ¬èª
                utterance.rate = 1.3; // è©±é€Ÿ(1.3å€é€Ÿã§èˆˆå¥®æ„Ÿã‚’æ¼”å‡º)
                utterance.pitch = 1.1; // ãƒ”ãƒƒãƒ(ã‚„ã‚„é«˜ã‚ã§æ˜ã‚‹ã„å°è±¡)
                utterance.volume = 1.0; // éŸ³é‡(æœ€å¤§)

                // éŸ³å£°ã‚’å†ç”Ÿ
                window.speechSynthesis.speak(utterance);
            }
        };

        /**
         * ãƒŸãƒ¥ãƒ¼ãƒˆçŠ¶æ…‹ã‚’åˆ‡ã‚Šæ›¿ãˆã‚‹é–¢æ•°
         * UIãƒœã‚¿ãƒ³ã‹ã‚‰å‘¼ã³å‡ºã•ã‚Œã€ã‚µã‚¦ãƒ³ãƒ‰ã®ON/OFFã‚’åˆ‡ã‚Šæ›¿ãˆã‚‹
         */
        function toggleMute() {
            // ãƒŸãƒ¥ãƒ¼ãƒˆçŠ¶æ…‹ã‚’åè»¢
            SoundManager.isMuted = !SoundManager.isMuted;
            // ãƒœã‚¿ãƒ³ã®ã‚¢ã‚¤ã‚³ãƒ³ã‚’æ›´æ–°(ğŸ”‡:ãƒŸãƒ¥ãƒ¼ãƒˆ, ğŸ”Š:éŸ³ã‚ã‚Š)
            document.getElementById('sound-toggle').innerText = SoundManager.isMuted ? 'ğŸ”‡' : 'ğŸ”Š';
            // ãƒŸãƒ¥ãƒ¼ãƒˆæ™‚ã¯ç’°å¢ƒéŸ³ã‚‚åœæ­¢
            if (SoundManager.isMuted) SoundManager.playAtmosphere(false);
        }

        // ================================================================================
        // ã‚²ãƒ¼ãƒ è¨­å®šå®šæ•°
        // ================================================================================
        // ã‚³ãƒ¼ã‚¹ã®å½¢çŠ¶ã‚„ãƒ¬ãƒ¼ã‚¹ã®åŸºæœ¬ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿ã‚’å®šç¾©
        const CONFIG = {
            laneWidth: 3.5,           // å„é¦¬ã®ãƒ¬ãƒ¼ãƒ³å¹…(ãƒ¡ãƒ¼ãƒˆãƒ«)
            trackRadiusX: 180,        // ãƒˆãƒ©ãƒƒã‚¯Xè»¸æ–¹å‘ã®åŠå¾„(ãƒ¡ãƒ¼ãƒˆãƒ«)
            trackRadiusZ: 90,         // ãƒˆãƒ©ãƒƒã‚¯Zè»¸æ–¹å‘ã®åŠå¾„(ãƒ¡ãƒ¼ãƒˆãƒ«)
            segmentCount: 200,        // ãƒˆãƒ©ãƒƒã‚¯ã‚’æ§‹æˆã™ã‚‹ã‚»ã‚°ãƒ¡ãƒ³ãƒˆæ•°(æ»‘ã‚‰ã‹ã•ã«å½±éŸ¿)
            finishLineT: 0.0,         // ã‚´ãƒ¼ãƒ«ãƒ©ã‚¤ãƒ³ã®ä½ç½®(0.0-1.0ã®æ¯”ç‡)
            startLineT: 0.0,          // ã‚¹ã‚¿ãƒ¼ãƒˆãƒ©ã‚¤ãƒ³ã®ä½ç½®(0.0-1.0ã®æ¯”ç‡)
            raceSpeedMult: 1.0        // ãƒ¬ãƒ¼ã‚¹é€Ÿåº¦ã®å…¨ä½“çš„ãªå€ç‡
        };

        // ================================================================================
        // é¦¬ã®ãƒ‡ãƒ¼ã‚¿å®šç¾©
        // ================================================================================
        // å„é¦¬ã®åå‰ã€è‰²ã€ã‚¹ã‚­ãƒ«ã€ç™ºå‹•æ¡ä»¶ã‚’å®šç¾©
        const HORSE_DATA = [
            {
                name: "ãƒ›ãƒ¯ã‚¤ãƒˆã‚¦ã‚£ãƒ³ãƒ‰",          // é¦¬å
                color: 0xF0F0F0,               // é¦¬ä½“ã®è‰²(16é€²æ•°)
                skill: "Divine Wind",          // ã‚¹ã‚­ãƒ«å
                skillDesc: "ãƒ©ã‚¹ãƒˆã‚¹ãƒ‘ãƒ¼ãƒˆè¶…åŠ é€Ÿ", // ã‚¹ã‚­ãƒ«èª¬æ˜
                icon: "ğŸŒªï¸",                    // ã‚¢ã‚¤ã‚³ãƒ³
                // ã‚¹ã‚­ãƒ«ç™ºå‹•æ¡ä»¶: é€²è¡Œç‡75%ä»¥ä¸Šã§ä½ç¢ºç‡(2%)ã§ç™ºå‹•
                check: (p, r) => p > 0.75 && r < 0.02,
                // ã‚¹ã‚­ãƒ«åŠ¹æœ: é€Ÿåº¦ã‚’1.6ï½2.0å€ã«åŠ é€Ÿ
                activate: (h) => h.speed *= (1.6 + Math.random() * 0.4)
            },
            {
                name: "ãƒãƒ§ã‚³ãƒãƒƒãƒ—",
                color: 0x5D4037,
                skill: "Sugar Rush",
                skillDesc: "ä¸­ç›¤ã§çˆ†ç™ºçš„ãªåŠ é€Ÿ",
                icon: "ğŸ©",
                // ã‚¹ã‚­ãƒ«ç™ºå‹•æ¡ä»¶: é€²è¡Œç‡40-60%ã§ä½ç¢ºç‡(2%)ã§ç™ºå‹•
                check: (p, r) => p > 0.4 && p < 0.6 && r < 0.02,
                // ã‚¹ã‚­ãƒ«åŠ¹æœ: é€Ÿåº¦ã‚’1.4ï½1.8å€ã«åŠ é€Ÿ
                activate: (h) => h.speed *= (1.4 + Math.random() * 0.4)
            },
            {
                name: "ãƒ–ãƒ©ãƒƒã‚¯ã‚¸ãƒ£ãƒƒã‚¯",
                color: 0x212121,
                skill: "Shadow Step",
                skillDesc: "ã‚¹ã‚¿ãƒŸãƒŠæ¸›ã‚‰ãšã«åŠ é€Ÿ",
                icon: "ğŸŒ‘",
                // ã‚¹ã‚­ãƒ«ç™ºå‹•æ¡ä»¶: é€²è¡Œç‡50%ä»¥ä¸Šã§æ¥µä½ç¢ºç‡(1%)ã§ç™ºå‹•
                check: (p, r) => p > 0.5 && r < 0.01,
                // ã‚¹ã‚­ãƒ«åŠ¹æœ: é€Ÿåº¦ã‚’1.3ï½1.6å€ã«åŠ é€Ÿ
                activate: (h) => h.speed *= (1.3 + Math.random() * 0.3)
            },
            {
                name: "ã‚´ãƒ¼ãƒ«ãƒ‡ãƒ³ãƒœãƒ¼ã‚¤",
                color: 0xFFD700,
                skill: "Gold Aura",
                skillDesc: "å…¨ä½“çš„ãªé€Ÿåº¦åº•ä¸Šã’",
                icon: "âœ¨",
                // ã‚¹ã‚­ãƒ«ç™ºå‹•æ¡ä»¶: é€²è¡Œç‡20%ä»¥ä¸Šã§æ¥µä½ç¢ºç‡(1%)ã§ç™ºå‹•
                check: (p, r) => p > 0.2 && r < 0.01,
                // ã‚¹ã‚­ãƒ«åŠ¹æœ: é€Ÿåº¦ã‚’1.2ï½1.4å€ã«åŠ é€Ÿã€åŠ¹æœæ™‚é–“6ç§’
                activate: (h) => { h.speed *= (1.2 + Math.random() * 0.2); h.skillTimer = 6.0; }
            },
            {
                name: "ã‚·ãƒ«ãƒãƒ¼ãƒ–ãƒ¬ãƒƒãƒˆ",
                color: 0xA9A9A9,
                skill: "Bullet Time",
                skillDesc: "ã‚´ãƒ¼ãƒ«ç›´å‰ã§ä¸€ç¬ã®ä¼¸ã³",
                icon: "ğŸš…",
                // ã‚¹ã‚­ãƒ«ç™ºå‹•æ¡ä»¶: é€²è¡Œç‡85%ä»¥ä¸Šã§ä½ç¢ºç‡(3%)ã§ç™ºå‹•
                check: (p, r) => p > 0.85 && r < 0.03,
                // ã‚¹ã‚­ãƒ«åŠ¹æœ: é€Ÿåº¦ã‚’2.0ï½3.0å€ã«æ€¥åŠ é€Ÿã€åŠ¹æœæ™‚é–“1.5ç§’
                activate: (h) => { h.speed *= (2.0 + Math.random() * 1.0); h.skillTimer = 1.5; }
            }
        ];

        // ================================================================================
        // ã‚²ãƒ¼ãƒ çŠ¶æ…‹ç®¡ç†
        // ================================================================================
        // ãƒ¬ãƒ¼ã‚¹ã®é€²è¡ŒçŠ¶æ³ã€æ‰€æŒé‡‘ã€ã‚«ãƒ¡ãƒ©è¨­å®šãªã©ã‚’ä¿æŒ
        const STATE = {
            wallet: 1000,              // æ‰€æŒé‡‘(ã‚²ãƒ¼ãƒ å†…é€šè²¨)
            betAmount: 100,            // è³­ã‘é‡‘é¡(å›ºå®š)
            selectedHorse: null,       // ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ãŒé¸æŠã—ãŸé¦¬ã®ID
            isRacing: false,           // ãƒ¬ãƒ¼ã‚¹ä¸­ã‹ã©ã†ã‹
            raceStarted: false,        // ãƒ¬ãƒ¼ã‚¹ãŒå®Ÿéš›ã«é–‹å§‹ã•ã‚ŒãŸã‹(ã‚«ã‚¦ãƒ³ãƒˆãƒ€ã‚¦ãƒ³å¾Œ)
            horses: [],                // é¦¬ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã®é…åˆ—
            gates: [],                 // ã‚²ãƒ¼ãƒˆã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã®é…åˆ—
            cameraMode: 0,             // ã‚«ãƒ¡ãƒ©ãƒ¢ãƒ¼ãƒ‰ (0:è¿½å¾“, 1:ä¸Šç©º, 2:ã‚µã‚¤ãƒ‰, 3:ã‚ªãƒ¼ãƒˆ)
            lastAutoSwitch: 0,         // ã‚ªãƒ¼ãƒˆã‚«ãƒ¡ãƒ©ã®æœ€å¾Œã®åˆ‡ã‚Šæ›¿ãˆæ™‚åˆ»
            autoShotType: 0,           // ã‚ªãƒ¼ãƒˆã‚«ãƒ¡ãƒ©ã®ç¾åœ¨ã®ã‚·ãƒ§ãƒƒãƒˆã‚¿ã‚¤ãƒ—
            trackCurve: null,          // ãƒˆãƒ©ãƒƒã‚¯ã®æ›²ç·šã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆ(CatmullRomCurve3)
            winner: null,              // å‹è€…ã®é¦¬ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆ
            weather: null,             // ç¾åœ¨ã®å¤©å€™ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆ
            trackCondition: null,      // é¦¬å ´çŠ¶æ…‹(è‰¯ã€é‡ãªã©)
            rainParticles: null,       // é›¨ã®ãƒ‘ãƒ¼ãƒ†ã‚£ã‚¯ãƒ«ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆ
            isWinningRun: false,       // å‹åˆ©èµ°è¡Œæ¼”å‡ºä¸­ã‹ã©ã†ã‹
            cameraShake: 0,            // ã‚«ãƒ¡ãƒ©ã‚·ã‚§ã‚¤ã‚¯ã®å¼·åº¦
            timeScale: 1.0,            // æ™‚é–“ã‚¹ã‚±ãƒ¼ãƒ«(ã‚¹ãƒ­ãƒ¼ãƒ¢ãƒ¼ã‚·ãƒ§ãƒ³ç”¨)
            currentCourse: null        // ç¾åœ¨é¸æŠã•ã‚Œã¦ã„ã‚‹ã‚³ãƒ¼ã‚¹
        };

        // ================================================================================
        // å¤©å€™ã‚·ã‚¹ãƒ†ãƒ 
        // ================================================================================
        // å„å¤©å€™ã®ç’°å¢ƒè¨­å®šã€ãƒ©ã‚¤ãƒ†ã‚£ãƒ³ã‚°ã€é¦¬å ´çŠ¶æ…‹ã¸ã®å½±éŸ¿ã‚’å®šç¾©
        const WEATHER_TYPES = [
            {
                name: 'æ™´ã‚Œ',                      // å¤©å€™å
                icon: 'â˜€',                       // ã‚¢ã‚¤ã‚³ãƒ³
                trackCondition: 'è‰¯',             // é¦¬å ´çŠ¶æ…‹
                speedMultiplier: 1.0,              // é€Ÿåº¦å€ç‡(æ¨™æº–)
                skyColor: 0x87CEEB,                // ç©ºã®è‰²(æ˜ã‚‹ã„é’)
                fogColor: 0x87CEEB,                // éœ§ã®è‰²
                ambientIntensity: 0.6,             // ç’°å¢ƒå…‰ã®å¼·åº¦
                directionalIntensity: 1.2,         // ç›´æ¥å…‰ã®å¼·åº¦
                directionalColor: 0xffffff         // ç›´æ¥å…‰ã®è‰²(ç™½)
            },
            {
                name: 'å¤•æ–¹',
                icon: 'ğŸŒ†',
                trackCondition: 'è‰¯',
                speedMultiplier: 1.0,
                skyColor: 0xFF6B35,                // ç©ºã®è‰²(ã‚ªãƒ¬ãƒ³ã‚¸)
                fogColor: 0xFF8C69,                // éœ§ã®è‰²(æ·¡ã„ã‚ªãƒ¬ãƒ³ã‚¸)
                ambientIntensity: 0.5,             // ç’°å¢ƒå…‰ã‚’ã‚„ã‚„æš—ã
                directionalIntensity: 0.9,         // ç›´æ¥å…‰ã‚’å¼±ã‚ã«
                directionalColor: 0xFFAA77         // ç›´æ¥å…‰ã®è‰²(æš–è‰²)
            },
            {
                name: 'é›¨',
                icon: 'â˜”',
                trackCondition: 'é‡',             // é¦¬å ´çŠ¶æ…‹ãŒæ‚ªã„
                speedMultiplier: 0.85,             // é€Ÿåº¦ãŒ15%ä½ä¸‹
                skyColor: 0x4A5568,                // ç©ºã®è‰²(æš—ã„ç°è‰²)
                fogColor: 0x718096,                // éœ§ã®è‰²(ç°è‰²)
                ambientIntensity: 0.4,             // ç’°å¢ƒå…‰ã‚’æš—ã
                directionalIntensity: 0.7,         // ç›´æ¥å…‰ã‚’å¼±ã
                directionalColor: 0xCCCCCC,        // ç›´æ¥å…‰ã®è‰²(æ·¡ã„ç°è‰²)
                rain: true                         // é›¨ãƒ‘ãƒ¼ãƒ†ã‚£ã‚¯ãƒ«ã‚’è¡¨ç¤º
            },
            {
                name: 'å¤œ',
                icon: 'ğŸŒƒ',
                trackCondition: 'è‰¯',
                speedMultiplier: 1.0,
                skyColor: 0x0A1128,                // ç©ºã®è‰²(æ·±ã„é’é»’)
                fogColor: 0x1A2332,                // éœ§ã®è‰²(æš—ã„é’ç°è‰²)
                ambientIntensity: 0.3,             // ç’°å¢ƒå…‰ã‚’éå¸¸ã«æš—ã
                directionalIntensity: 1.5,         // ç›´æ¥å…‰ã‚’å¼·ã(ç…§æ˜åŠ¹æœ)
                directionalColor: 0xFFFFDD,        // ç›´æ¥å…‰ã®è‰²(æ·¡ã„é»„è‰²)
                night: true                        // å¤œé–“ãƒ•ãƒ©ã‚°
            }
        ];

        // --- Three.js åˆæœŸåŒ– ---
        // ã‚·ãƒ¼ãƒ³ã€ã‚«ãƒ¡ãƒ©ã€ãƒ¬ãƒ³ãƒ€ãƒ©ãƒ¼ã€ãƒ©ã‚¤ãƒˆã®ã‚»ãƒƒãƒˆã‚¢ãƒƒãƒ—
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0x87CEEB);
        scene.fog = new THREE.Fog(0x87CEEB, 40, 350);

        const camera = new THREE.PerspectiveCamera(50, window.innerWidth / window.innerHeight, 0.5, 1000);
        const renderer = new THREE.WebGLRenderer({ antialias: true, powerPreference: "high-performance" });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.shadowMap.enabled = true;
        renderer.shadowMap.type = THREE.PCFSoftShadowMap;
        renderer.outputEncoding = THREE.sRGBEncoding;
        document.body.appendChild(renderer.domElement);

        // --- Lighting ---
        const hemiLight = new THREE.HemisphereLight(0xffffff, 0xffffff, 0.6);
        scene.add(hemiLight);

        const dirLight = new THREE.DirectionalLight(0xffffff, 1.2);
        dirLight.position.set(100, 200, 50);
        dirLight.castShadow = true;
        dirLight.shadow.mapSize.width = 2048;
        dirLight.shadow.mapSize.height = 2048;
        const d = 250;
        dirLight.shadow.camera.left = -d; dirLight.shadow.camera.right = d;
        dirLight.shadow.camera.top = d; dirLight.shadow.camera.bottom = -d;
        scene.add(dirLight);

        // --- Weather Functions ---
        function createRainParticles() {
            const rainGeo = new THREE.BufferGeometry();
            const rainCount = 2000;
            const positions = [];

            for (let i = 0; i < rainCount; i++) {
                positions.push(
                    (Math.random() - 0.5) * 400,
                    Math.random() * 200,
                    (Math.random() - 0.5) * 400
                );
            }

            rainGeo.setAttribute('position', new THREE.Float32BufferAttribute(positions, 3));
            const rainMaterial = new THREE.PointsMaterial({
                color: 0xaaaaaa,
                size: 0.5,
                transparent: true,
                opacity: 0.6
            });

            return new THREE.Points(rainGeo, rainMaterial);
        }

        function applyWeather(weather) {
            // Set sky and fog
            scene.background.setHex(weather.skyColor);
            scene.fog.color.setHex(weather.fogColor);

            // Update lighting
            hemiLight.intensity = weather.ambientIntensity;
            dirLight.intensity = weather.directionalIntensity;
            dirLight.color.setHex(weather.directionalColor);

            // Remove existing rain if any
            if (STATE.rainParticles) {
                scene.remove(STATE.rainParticles);
                STATE.rainParticles = null;
            }

            // Add rain particles if rainy weather
            if (weather.rain) {
                STATE.rainParticles = createRainParticles();
                scene.add(STATE.rainParticles);
            }

            STATE.weather = weather;
            STATE.trackCondition = weather.trackCondition;
        }

        // --- ã‚³ãƒ¼ã‚¹ & ãƒˆãƒ©ãƒƒã‚¯ç”Ÿæˆ ---
        let trackGroup = null;

        // ã‚³ãƒ¼ã‚¹å½¢çŠ¶ã®ãƒ‡ãƒ¼ã‚¿å®šç¾© (ãƒ™ã‚¸ã‚§æ›²ç·šã®åˆ¶å¾¡ç‚¹)
        const COURSES = [
            {
                name: "Classic Circuit",
                points: [
                    new THREE.Vector3(200, 0, 0),
                    new THREE.Vector3(180, 0, 80),
                    new THREE.Vector3(100, 0, 120),
                    new THREE.Vector3(-50, 0, 100),
                    new THREE.Vector3(-150, 0, 40),
                    new THREE.Vector3(-220, 0, 0),
                    new THREE.Vector3(-180, 0, -80),
                    new THREE.Vector3(-50, 0, -120),
                    new THREE.Vector3(50, 0, -80),
                    new THREE.Vector3(150, 0, -60),
                    new THREE.Vector3(200, 0, 0)
                ]
            },
            {
                name: "Forest Oval",
                points: [
                    new THREE.Vector3(200, 0, 0),
                    new THREE.Vector3(200, 0, 80),
                    new THREE.Vector3(0, 0, 120),
                    new THREE.Vector3(-200, 0, 80),
                    new THREE.Vector3(-200, 0, 0),
                    new THREE.Vector3(-200, 0, -80),
                    new THREE.Vector3(0, 0, -120),
                    new THREE.Vector3(200, 0, -80),
                    new THREE.Vector3(200, 0, 0)
                ]
            },
            {
                name: "Dragon's Long Run",
                points: [
                    new THREE.Vector3(200, 0, 0),    // Start
                    new THREE.Vector3(250, 0, 100),  // Wide turn
                    new THREE.Vector3(150, 0, 180),  // Deep curve
                    new THREE.Vector3(0, 0, 150),    // Inner twist
                    new THREE.Vector3(-100, 0, 200), // Technical section
                    new THREE.Vector3(-250, 0, 120), // Backstretch start
                    new THREE.Vector3(-320, 0, 0),   // Far edge (Long straight)
                    new THREE.Vector3(-280, 0, -150),// Sharp turn
                    new THREE.Vector3(-100, 0, -100),// S-curve entry
                    new THREE.Vector3(0, 0, -160),   // S-curve exit
                    new THREE.Vector3(120, 0, -120), // Final turn setup
                    new THREE.Vector3(200, 0, 0)     // Loop close
                ]
            },
            {
                name: "Crescent Mile",
                points: [
                    new THREE.Vector3(200, 0, 0),
                    new THREE.Vector3(220, 0, 60),
                    new THREE.Vector3(140, 0, 120),
                    new THREE.Vector3(40, 0, 140),
                    new THREE.Vector3(-60, 0, 120),
                    new THREE.Vector3(-160, 0, 80),
                    new THREE.Vector3(-220, 0, 0),
                    new THREE.Vector3(-160, 0, -80),
                    new THREE.Vector3(-40, 0, -140),
                    new THREE.Vector3(80, 0, -120),
                    new THREE.Vector3(180, 0, -60),
                    new THREE.Vector3(200, 0, 0)
                ]
            }
        ];

        function createTrackCurve(points) {
            return new THREE.CatmullRomCurve3(points, true, 'centripetal');
        }

        function cleanupLevel() {
            // Remove old track group
            if (trackGroup) {
                scene.remove(trackGroup);
                // Dispose logic could be added here for geometries/materials to avoid memory leaks
                // For now, relying on GC as per simple implementation
                trackGroup = null;
            }

            // Remove Gates
            if (STATE.gates.length > 0) {
                STATE.gates.forEach(g => g.dispose());
                STATE.gates = [];
            }

            // Remove Spectators
            if (spectatorManager) {
                spectatorManager.dispose();
                spectatorManager = null;
            }
        }

        function buildTrack(courseData) {
            cleanupLevel();

            STATE.trackCurve = createTrackCurve(courseData.points);
            trackGroup = new THREE.Group();
            scene.add(trackGroup);

            // Ground
            const groundGeo = new THREE.PlaneGeometry(1000, 1000);
            // Create material immediately so we can assign texture later
            const groundMat = new THREE.MeshStandardMaterial({ color: 0x4CAF50, roughness: 1.0 });

            const textureLoader = new THREE.TextureLoader();
            const grassTexture = textureLoader.load(
                'textures/grass.png',
                function (texture) {
                    texture.wrapS = THREE.RepeatWrapping;
                    texture.wrapT = THREE.RepeatWrapping;
                    texture.repeat.set(25, 25);
                    groundMat.map = texture;
                    groundMat.needsUpdate = true;
                },
                undefined,
                function (error) {
                    console.warn('Error loading grass texture, using procedural fallback');
                    const canvas = document.createElement('canvas');
                    canvas.width = 512; canvas.height = 512;
                    const ctx = canvas.getContext('2d');
                    ctx.fillStyle = '#4CAF50';
                    ctx.fillRect(0, 0, 512, 512);
                    for (let i = 0; i < 10000; i++) {
                        ctx.fillStyle = Math.random() > 0.5 ? '#66BB6A' : '#388E3C';
                        const size = Math.random() * 3 + 1;
                        ctx.fillRect(Math.random() * 512, Math.random() * 512, size, size);
                    }
                    const fallbackTexture = new THREE.CanvasTexture(canvas);
                    fallbackTexture.wrapS = THREE.RepeatWrapping;
                    fallbackTexture.wrapT = THREE.RepeatWrapping;
                    fallbackTexture.repeat.set(25, 25);
                    groundMat.map = fallbackTexture;
                    groundMat.needsUpdate = true;
                }
            );

            const ground = new THREE.Mesh(groundGeo, groundMat);
            ground.rotation.x = -Math.PI / 2;
            ground.receiveShadow = true;
            trackGroup.add(ground);

            // Track Surface
            const trackWidth = CONFIG.laneWidth * 6;
            const points = STATE.trackCurve.getSpacedPoints(200);
            const vertices = [], uvs = [], indices = [];

            points.forEach((p, i) => {
                const tangent = STATE.trackCurve.getTangentAt(i / 200).normalize();
                const normal = new THREE.Vector3(-tangent.z, 0, tangent.x).normalize();
                const p1 = p.clone().add(normal.clone().multiplyScalar(trackWidth / 2));
                const p2 = p.clone().add(normal.clone().multiplyScalar(-trackWidth / 2));
                vertices.push(p1.x, 0.5, p1.z, p2.x, 0.5, p2.z);
                const v = i / 10;
                uvs.push(0, v, 1, v);
            });
            for (let i = 0; i < points.length - 1; i++) {
                const offset = i * 2;
                indices.push(offset, offset + 1, offset + 2, offset + 1, offset + 3, offset + 2);
            }
            const trackGeo = new THREE.BufferGeometry();
            trackGeo.setAttribute('position', new THREE.Float32BufferAttribute(vertices, 3));
            trackGeo.setAttribute('uv', new THREE.Float32BufferAttribute(uvs, 2));
            trackGeo.setIndex(indices);
            trackGeo.computeVertexNormals();

            // Track Texture
            const trackTex = textureLoader.load('textures/dirt.png', (t) => {
                t.wrapS = THREE.RepeatWrapping;
                t.wrapT = THREE.RepeatWrapping;
                t.repeat.set(4, 4);
            }, undefined, (err) => {
                const sandCanvas = document.createElement('canvas');
                sandCanvas.width = 512; sandCanvas.height = 512;
                const sCtx = sandCanvas.getContext('2d');
                sCtx.fillStyle = '#6B4423'; sCtx.fillRect(0, 0, 512, 512);
                for (let i = 0; i < 10000; i++) {
                    const rand = Math.random();
                    if (rand < 0.4) sCtx.fillStyle = '#8B5A3C';
                    else if (rand < 0.7) sCtx.fillStyle = '#5C3317';
                    else sCtx.fillStyle = '#A0522D';
                    sCtx.fillRect(Math.random() * 512, Math.random() * 512, 4, 4);
                }
                const fallback = new THREE.CanvasTexture(sandCanvas);
                fallback.wrapS = THREE.RepeatWrapping;
                fallback.wrapT = THREE.RepeatWrapping;
                fallback.repeat.set(4, 4);
                trackMesh.material.map = fallback;
                trackMesh.material.needsUpdate = true;
            });

            const trackMesh = new THREE.Mesh(trackGeo, new THREE.MeshStandardMaterial({
                map: trackTex,
                color: 0xffffff,
                roughness: 1.0,
                side: THREE.DoubleSide
            }));
            trackMesh.receiveShadow = true;
            trackMesh.castShadow = true;
            trackGroup.add(trackMesh);

            // Objects
            const innerRailPoints = [], outerRailPoints = [];
            const poleGeo = new THREE.CylinderGeometry(0.1, 0.1, 1.2);
            const poleMat = new THREE.MeshStandardMaterial({ color: 0xffffff });

            points.forEach((p, i) => {
                const tangent = STATE.trackCurve.getTangentAt(i / 200).normalize();
                const normal = new THREE.Vector3(-tangent.z, 0, tangent.x).normalize();

                if (i % 5 === 0) {
                    const posIn = p.clone().add(normal.clone().multiplyScalar(trackWidth / 2 * 1.05));
                    const poleIn = new THREE.Mesh(poleGeo, poleMat); poleIn.position.set(posIn.x, 0.6, posIn.z);
                    trackGroup.add(poleIn);

                    const posOut = p.clone().add(normal.clone().multiplyScalar(-trackWidth / 2 * 1.05));
                    const poleOut = new THREE.Mesh(poleGeo, poleMat); poleOut.position.set(posOut.x, 0.6, posOut.z);
                    trackGroup.add(poleOut);
                }
                innerRailPoints.push(p.clone().add(normal.clone().multiplyScalar(trackWidth / 2 * 1.05)).setY(1.0));
                outerRailPoints.push(p.clone().add(normal.clone().multiplyScalar(-trackWidth / 2 * 1.05)).setY(1.0));
            });
            trackGroup.add(new THREE.Mesh(new THREE.TubeGeometry(new THREE.CatmullRomCurve3(innerRailPoints, true), 200, 0.08, 6, true), new THREE.MeshStandardMaterial({ color: 0xffffff })));
            trackGroup.add(new THREE.Mesh(new THREE.TubeGeometry(new THREE.CatmullRomCurve3(outerRailPoints, true), 200, 0.08, 6, true), new THREE.MeshStandardMaterial({ color: 0xffffff })));

            const goalT = CONFIG.finishLineT;
            const goalPoint = STATE.trackCurve.getPointAt(goalT);
            const prevPoint = STATE.trackCurve.getPointAt(0.99);
            const goalGroup = new THREE.Group();
            goalGroup.position.copy(goalPoint); goalGroup.lookAt(prevPoint);
            const postGeo = new THREE.CylinderGeometry(0.3, 0.3, 8); const postMat = new THREE.MeshStandardMaterial({ color: 0xffffff });
            const gp1 = new THREE.Mesh(postGeo, postMat); gp1.position.set(-trackWidth / 2 - 1, 4, 0);
            const gp2 = new THREE.Mesh(postGeo, postMat); gp2.position.set(trackWidth / 2 + 1, 4, 0);
            const banner = new THREE.Mesh(new THREE.BoxGeometry(trackWidth + 4, 2, 0.5), new THREE.MeshStandardMaterial({ color: 0xB71C1C }));
            banner.position.set(0, 7, 0);
            const tCtx = document.createElement('canvas').getContext('2d'); tCtx.canvas.width = 256; tCtx.canvas.height = 64;
            tCtx.fillStyle = '#B71C1C'; tCtx.fillRect(0, 0, 256, 64); tCtx.fillStyle = 'white'; tCtx.font = 'bold 40px Arial'; tCtx.textAlign = 'center'; tCtx.textBaseline = 'middle'; tCtx.fillText('GOAL', 128, 32);
            banner.material = new THREE.MeshStandardMaterial({ map: new THREE.CanvasTexture(tCtx.canvas) });
            goalGroup.add(gp1, gp2, banner); trackGroup.add(goalGroup);

            const standGroup = new THREE.Group();
            standGroup.add(new THREE.Mesh(new THREE.BoxGeometry(60, 20, 30), new THREE.MeshStandardMaterial({ color: 0xffffff })).translateX(0).translateY(10));
            standGroup.add(new THREE.Mesh(new THREE.BoxGeometry(64, 2, 40), new THREE.MeshStandardMaterial({ color: 0xeeeeee })).translateY(25).translateZ(5));
            const goalTangent = STATE.trackCurve.getTangentAt(goalT).normalize();
            const goalNormal = new THREE.Vector3(-goalTangent.z, 0, goalTangent.x).normalize();
            standGroup.position.copy(goalPoint.clone().add(goalNormal.multiplyScalar(-45))); standGroup.lookAt(goalPoint); trackGroup.add(standGroup);

            // Trees
            const trunkGeo = new THREE.CylinderGeometry(0.4, 0.6, 2.5, 7);
            const trunkMat = new THREE.MeshStandardMaterial({ color: 0x4A3828, roughness: 0.9 });
            const foliageMat = new THREE.MeshStandardMaterial({ color: 0x2E7D32, roughness: 0.8, flatShading: true });
            const foliageGeo1 = new THREE.ConeGeometry(3.0, 4.0, 7);
            const foliageGeo2 = new THREE.ConeGeometry(2.3, 3.5, 7);
            const foliageGeo3 = new THREE.ConeGeometry(1.6, 3.0, 7);

            const treeCount = 60;
            for (let i = 0; i < treeCount; i++) {
                const t = Math.random();
                const p = STATE.trackCurve.getPointAt(t);
                const tan = STATE.trackCurve.getTangentAt(t).normalize();
                const nor = new THREE.Vector3(-tan.z, 0, tan.x).normalize();
                const dist = 35 + Math.random() * 60;
                const side = Math.random() > 0.3 ? 1 : -1;
                const treePos = p.add(nor.multiplyScalar(dist * side));
                const tree = new THREE.Group();
                const trunk = new THREE.Mesh(trunkGeo, trunkMat); trunk.position.y = 1.25; trunk.castShadow = true; trunk.receiveShadow = true; tree.add(trunk);
                const l1 = new THREE.Mesh(foliageGeo1, foliageMat); l1.position.y = 3.0; l1.receiveShadow = true; l1.rotation.y = Math.random(); tree.add(l1);
                const l2 = new THREE.Mesh(foliageGeo2, foliageMat); l2.position.y = 5.0; l2.receiveShadow = true; l2.rotation.y = Math.random(); tree.add(l2);
                const l3 = new THREE.Mesh(foliageGeo3, foliageMat); l3.position.y = 7.0; l3.receiveShadow = true; l3.rotation.y = Math.random(); tree.add(l3);
                const scale = 0.8 + Math.random() * 0.6; tree.scale.set(scale, scale, scale); tree.rotation.y = Math.random() * Math.PI * 2;
                tree.position.copy(treePos); trackGroup.add(tree);
            }

            // Initialize Spectators for new track
            spectatorManager = new SpectatorManager(scene);

            // Re-initialize Gates
            if (STATE.horses.length > 0) {
                // If horses exist (rebuild), we need to remake gates for them
                STATE.horses.forEach((h, index) => {
                    const gate = new Gate((index - 2) * CONFIG.laneWidth);
                    STATE.gates.push(gate);
                });
            }
        }

        function selectRandomCourse() {
            const courseIdx = Math.floor(Math.random() * COURSES.length);
            STATE.currentCourse = COURSES[courseIdx];
            console.log("Selected Course: ", STATE.currentCourse.name);

            const el = document.getElementById('course-name-display');
            if (el) el.innerText = STATE.currentCourse.name;

            document.getElementById('progress-bar').style.width = '70%'; // Update loading visual
            buildTrack(STATE.currentCourse);
        }

        // selectRandomCourse(); // Removed global call to avoid hoisting errors with Classes

        // --- ã‚²ãƒ¼ãƒˆã‚¯ãƒ©ã‚¹ ---
        // ã‚¹ã‚¿ãƒ¼ãƒˆã‚²ãƒ¼ãƒˆã®3Dãƒ¢ãƒ‡ãƒ«ç”Ÿæˆã¨ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³åˆ¶å¾¡
        const GATE_GEO = {
            post: new THREE.BoxGeometry(0.2, 4, 0.2),
            top: new THREE.BoxGeometry(3.2, 0.4, 0.4),
            door: new THREE.BoxGeometry(1.4, 3, 0.1),
            bars: new THREE.BoxGeometry(1.2, 2.5, 0.15)
        };

        class Gate {
            constructor(laneOffset) {
                this.mesh = new THREE.Group();
                const t = CONFIG.startLineT;
                const point = STATE.trackCurve.getPointAt(t);
                const tangent = STATE.trackCurve.getTangentAt(t).normalize();
                const normal = new THREE.Vector3(-tangent.z, 0, tangent.x).normalize();
                const pos = point.add(normal.multiplyScalar(laneOffset));
                this.mesh.position.copy(pos); this.mesh.lookAt(pos.clone().add(tangent));

                const mat = new THREE.MeshStandardMaterial({ color: 0x222222, roughness: 0.5 });
                const doorMat = new THREE.MeshStandardMaterial({ color: 0xdddddd, roughness: 0.5 });

                const p1 = new THREE.Mesh(GATE_GEO.post, mat); p1.position.set(-1.5, 2, 0);
                const p2 = new THREE.Mesh(GATE_GEO.post, mat); p2.position.set(1.5, 2, 0);
                const top = new THREE.Mesh(GATE_GEO.top, mat); top.position.set(0, 3.8, 0);
                this.mesh.add(p1, p2, top);

                const createDoor = (isLeft) => {
                    const group = new THREE.Group(); group.position.set(isLeft ? -1.5 : 1.5, 2, 0);
                    const door = new THREE.Mesh(GATE_GEO.door, doorMat); door.position.set(isLeft ? 0.7 : -0.7, 0, 0);
                    const bars = new THREE.Mesh(GATE_GEO.bars, new THREE.MeshStandardMaterial({ color: 0xffffff, wireframe: true }));
                    bars.position.set(isLeft ? 0.7 : -0.7, 0, 0);
                    group.add(door, bars);
                    return group;
                };
                this.leftDoor = createDoor(true); this.rightDoor = createDoor(false);
                this.mesh.add(this.leftDoor, this.rightDoor);
                this.isOpen = false; scene.add(this.mesh);
            }
            open() { this.isOpen = true; }
            reset() { this.isOpen = false; this.leftDoor.rotation.y = 0; this.rightDoor.rotation.y = 0; }
            update(delta) {
                if (this.isOpen && this.leftDoor.rotation.y < 1.8) {
                    const speed = 8.0; this.leftDoor.rotation.y += delta * speed; this.rightDoor.rotation.y -= delta * speed;
                }
            }
            dispose() {
                if (this.mesh) {
                    scene.remove(this.mesh);
                    // traverse and dispose geometry/material if needed
                    this.mesh = null;
                }
            }
        }

        // --- è¦³å®¢ã‚·ã‚¹ãƒ†ãƒ  ---
        // InstancedMeshã‚’ä½¿ç”¨ã—ã¦å¤§é‡ã®è¦³å®¢ã‚’åŠ¹ç‡çš„ã«æç”»
        class SpectatorManager {
            constructor(scene, count = 1500) {
                this.scene = scene;
                this.count = count;
                this.dummy = new THREE.Object3D();

                // Low-poly spectator geometry - INCREASED SIZE for visibility
                const geometry = new THREE.BoxGeometry(1.2, 2.0, 1.2);
                const material = new THREE.MeshStandardMaterial({
                    color: 0xffffff,
                    roughness: 0.8
                });

                this.mesh = new THREE.InstancedMesh(geometry, material, count);
                this.mesh.instanceMatrix.setUsage(THREE.DynamicDrawUsage);
                this.mesh.castShadow = true;
                this.mesh.receiveShadow = true;

                // Position the entire mesh group to match the stand location
                const goalT = CONFIG.finishLineT;
                const goalPoint = STATE.trackCurve.getPointAt(goalT);
                const goalTangent = STATE.trackCurve.getTangentAt(goalT).normalize();
                const goalNormal = new THREE.Vector3(-goalTangent.z, 0, goalTangent.x).normalize();

                // Same transform as the Stand Group in buildTrack
                // Start from the same base position: goalPoint + -45 * goalNormal
                const standDistance = 45;
                const standPos = goalPoint.clone().add(goalNormal.multiplyScalar(-standDistance));

                this.mesh.position.copy(standPos);
                this.mesh.lookAt(goalPoint);

                // Important: Add to scene
                this.scene.add(this.mesh);

                this.spectators = [];
                const colors = [0xff0000, 0x00ff00, 0x0000ff, 0xffff00, 0xff00ff, 0x00ffff, 0xffffff, 0x111111, 0xFF9800, 0x4CAF50];

                // Grid layout for "Bleachers" style - REDUCED density for visibility
                const rows = 12;
                const cols = 40;
                const standWidth = 55; // Slightly less than BoxWidth 60

                // Stand Local Dimensions (Approx from buildTrack box geometry)
                // Box(60, 20, 30) translated Y+10.
                // Local Y range of top surface: ~20.
                // Local Z range: -15 to +15.
                // We want stairs going back and up.

                // Let's assume the "front" of the stand is at Z=+15 (closer to track) and "back" is Z=-15.
                const depthStart = 12; // Front of stand (local Z)
                const depthEnd = -12; // Back of stand
                const heightStart = 21; // Bottom of seating area (on top of box)
                const heightEnd = 35; // Top of seating area

                let index = 0;
                for (let r = 0; r < rows; r++) {
                    const rowProgress = r / (rows - 1);
                    // Z goes from Positive (Front) to Negative (Back)
                    const z = depthStart - (rowProgress * (depthStart - depthEnd));
                    // Y goes from Low to High
                    const y = heightStart + (rowProgress * (heightEnd - heightStart));

                    for (let c = 0; c < cols; c++) {
                        if (index >= count) break;

                        // Spread columns centered
                        const colProgress = c / (cols - 1);
                        const x = (colProgress - 0.5) * standWidth;

                        // Add some randomness
                        const randX = (Math.random() - 0.5) * 0.4;
                        const randZ = (Math.random() - 0.5) * 0.2;

                        // Local position relative to the mesh group
                        const pos = new THREE.Vector3(x + randX, y, z + randZ);
                        const color = new THREE.Color(colors[Math.floor(Math.random() * colors.length)]);

                        this.mesh.setColorAt(index, color);

                        this.spectators.push({
                            basePos: pos, // Local position
                            offsetY: Math.random() * 0.5,
                            jumpPhase: Math.random() * Math.PI * 2,
                            speed: 0.5 + Math.random()
                        });

                        this.dummy.position.copy(pos);
                        this.dummy.rotation.set(0, 0, 0); // Reset rotation to local aligned
                        this.dummy.updateMatrix();
                        this.mesh.setMatrixAt(index, this.dummy.matrix);

                        index++;
                    }
                }
                this.mesh.instanceMatrix.needsUpdate = true;
            }

            update(time, leaderProgress) {
                // Determine excitement level
                const isExcited = (leaderProgress > 0.92 && leaderProgress < 1.0) || STATE.winner;
                const jumpBaseSpeed = isExcited ? 15 : 2;
                const jumpBaseHeight = isExcited ? 0.6 : 0.05;

                for (let i = 0; i < this.spectators.length; i++) {
                    const s = this.spectators[i]; // Use length instead of count just in case
                    if (!s) break;

                    // Simple jump animation
                    const yAnim = Math.sin(time * jumpBaseSpeed * s.speed + s.jumpPhase) * jumpBaseHeight;

                    this.dummy.position.copy(s.basePos);
                    this.dummy.position.y += Math.max(0, yAnim);
                    this.dummy.updateMatrix();
                    this.mesh.setMatrixAt(i, this.dummy.matrix);
                }
                this.mesh.instanceMatrix.needsUpdate = true;
            }

            dispose() {
                if (this.mesh) {
                    this.scene.remove(this.mesh);
                    this.mesh.dispose();
                    this.mesh = null;
                }
            }
        }

        let spectatorManager;

        // --- ãƒ‘ãƒ¼ãƒ†ã‚£ã‚¯ãƒ«ã‚·ã‚¹ãƒ†ãƒ  ---
        // ç ‚åŸƒã€æ°´ã—ã¶ãã€ã‚¹ã‚­ãƒ«ã‚¨ãƒ•ã‚§ã‚¯ãƒˆãªã©ã®ç²’å­åˆ¶å¾¡
        const ParticleType = { DUST: 0, SPLASH: 1, SKILL: 2 };

        class ParticleManager {
            constructor(scene, maxParticles = 3000) {
                this.maxParticles = maxParticles;
                this.particleCount = 0;
                this.scene = scene;

                // Geometry setup
                this.geometry = new THREE.BufferGeometry();
                this.positions = new Float32Array(maxParticles * 3);
                this.colors = new Float32Array(maxParticles * 3);
                this.sizes = new Float32Array(maxParticles);

                this.geometry.setAttribute('position', new THREE.BufferAttribute(this.positions, 3));
                this.geometry.setAttribute('color', new THREE.BufferAttribute(this.colors, 3));
                this.geometry.setAttribute('size', new THREE.BufferAttribute(this.sizes, 1));

                // Texture Loading
                const textureLoader = new THREE.TextureLoader();
                // If we had a real file we would load it, but we fallback to generated canvas
                this.sparkleTexture = this.createSparkleTexture();

                this.material = new THREE.PointsMaterial({
                    size: 1,
                    vertexColors: true,
                    map: this.sparkleTexture, // Use sparkle texture for everything (looks okay for dust too, or mix)
                    transparent: true,
                    opacity: 0.8,
                    depthWrite: false,
                    blending: THREE.AdditiveBlending // Additive for glowing effect
                });

                this.mesh = new THREE.Points(this.geometry, this.material);
                this.mesh.frustumCulled = false;
                scene.add(this.mesh);

                // Particle data
                this.particles = [];
                for (let i = 0; i < maxParticles; i++) {
                    this.particles.push({
                        active: false,
                        life: 0,
                        maxLife: 1.0,
                        velocity: new THREE.Vector3(),
                        type: ParticleType.DUST
                    });
                    this.positions[i * 3 + 1] = -1000;
                }
            }

            createSparkleTexture() {
                const canvas = document.createElement('canvas');
                canvas.width = 64; canvas.height = 64;
                const ctx = canvas.getContext('2d');

                // Draw star shape
                const cx = 32, cy = 32, spikes = 4, outerRadius = 30, innerRadius = 5;
                let rot = Math.PI / 2 * 3;
                let x = cx, y = cy;
                const step = Math.PI / spikes;

                ctx.beginPath();
                ctx.moveTo(cx, cy - outerRadius);
                for (let i = 0; i < spikes; i++) {
                    x = cx + Math.cos(rot) * outerRadius;
                    y = cy + Math.sin(rot) * outerRadius;
                    ctx.lineTo(x, y);
                    rot += step;

                    x = cx + Math.cos(rot) * innerRadius;
                    y = cy + Math.sin(rot) * innerRadius;
                    ctx.lineTo(x, y);
                    rot += step;
                }
                ctx.lineTo(cx, cy - outerRadius);
                ctx.closePath();

                // Radial Gradient for bloom
                const grad = ctx.createRadialGradient(cx, cy, 0, cx, cy, 32);
                grad.addColorStop(0, 'rgba(255, 255, 255, 1)');
                grad.addColorStop(0.4, 'rgba(255, 255, 255, 0.8)');
                grad.addColorStop(1, 'rgba(255, 255, 255, 0)');

                ctx.fillStyle = grad;
                ctx.fill();

                const texture = new THREE.CanvasTexture(canvas);
                return texture;
            }

            spawn(pos, type) {
                let index = -1;
                for (let i = 0; i < this.maxParticles; i++) {
                    if (!this.particles[i].active) {
                        index = i;
                        break;
                    }
                }

                if (index === -1) return;

                const p = this.particles[index];
                p.active = true;
                p.type = type;

                this.positions[index * 3] = pos.x;
                this.positions[index * 3 + 1] = pos.y;
                this.positions[index * 3 + 2] = pos.z;

                if (type === ParticleType.SKILL) {
                    p.life = 1.0 + Math.random() * 0.5;
                    p.maxLife = p.life;
                    // Upward spiral / burst
                    p.velocity.set(
                        (Math.random() - 0.5) * 6,
                        Math.random() * 10 + 5,
                        (Math.random() - 0.5) * 6
                    );
                    // Gold/White
                    this.colors[index * 3] = 1.0;
                    this.colors[index * 3 + 1] = 0.9;
                    this.colors[index * 3 + 2] = 0.4;
                    this.sizes[index] = Math.random() * 8 + 4;

                } else if (type === ParticleType.DUST) {
                    p.life = 0.5 + Math.random() * 0.5;
                    p.maxLife = p.life;
                    p.velocity.set(
                        (Math.random() - 0.5) * 4,
                        Math.random() * 2 + 1,
                        (Math.random() - 0.5) * 4
                    );
                    // Dusty Brown (lightened for additive blending)
                    this.colors[index * 3] = 0.5;
                    this.colors[index * 3 + 1] = 0.4;
                    this.colors[index * 3 + 2] = 0.3;
                    this.sizes[index] = Math.random() * 4 + 2;
                } else { // SPLASH
                    p.life = 0.4 + Math.random() * 0.3;
                    p.maxLife = p.life;
                    p.velocity.set(
                        (Math.random() - 0.5) * 6,
                        Math.random() * 5 + 3,
                        (Math.random() - 0.5) * 6
                    );
                    // Watery Blue
                    this.colors[index * 3] = 0.4;
                    this.colors[index * 3 + 1] = 0.6;
                    this.colors[index * 3 + 2] = 1.0;
                    this.sizes[index] = Math.random() * 3 + 1;
                }
            }

            update(delta) {
                for (let i = 0; i < this.maxParticles; i++) {
                    const p = this.particles[i];
                    if (!p.active) continue;

                    p.life -= delta;
                    if (p.life <= 0) {
                        p.active = false;
                        this.positions[i * 3 + 1] = -1000;
                        this.sizes[i] = 0;
                        continue;
                    }

                    // Physics
                    this.positions[i * 3] += p.velocity.x * delta * 5;
                    this.positions[i * 3 + 1] += p.velocity.y * delta * 5;
                    this.positions[i * 3 + 2] += p.velocity.z * delta * 5;

                    if (p.type === ParticleType.SKILL) {
                        p.velocity.y += delta * 2; // Rise
                        // Twinkle size
                        this.sizes[i] = (Math.sin(Date.now() * 0.01 + i) * 0.5 + 1) * (p.life / p.maxLife * 8);
                    } else if (p.type === ParticleType.DUST) {
                        p.velocity.y *= 0.95;
                        const r = p.life / p.maxLife;
                        this.sizes[i] = (1 - r) * 5 + 2;
                    } else { // SPLASH
                        p.velocity.y -= delta * 25;
                        const r = p.life / p.maxLife;
                        this.sizes[i] = r * 3;
                    }
                }

                this.geometry.attributes.position.needsUpdate = true;
                this.geometry.attributes.color.needsUpdate = true;
                this.geometry.attributes.size.needsUpdate = true;
            }
        }

        const particleManager = new ParticleManager(scene);

        // --- ç´™å¹é›ªã‚·ã‚¹ãƒ†ãƒ  ---
        // ã‚´ãƒ¼ãƒ«æ™‚ã®æ¼”å‡ºç”¨
        class ConfettiManager {
            constructor(scene, count = 1000) {
                this.count = count;
                this.scene = scene;
                this.active = false;

                const geometry = new THREE.PlaneGeometry(0.3, 0.3);
                const material = new THREE.MeshBasicMaterial({ side: THREE.DoubleSide });
                this.mesh = new THREE.InstancedMesh(geometry, material, count);
                this.mesh.instanceMatrix.setUsage(THREE.DynamicDrawUsage);

                this.dummy = new THREE.Object3D();
                this.particles = [];

                const colors = [0xFF0000, 0x00FF00, 0x0000FF, 0xFFFF00, 0xFF00FF, 0x00FFFF, 0xFFFFFF];

                for (let i = 0; i < count; i++) {
                    this.particles.push({
                        pos: new THREE.Vector3(),
                        vel: new THREE.Vector3(),
                        rot: new THREE.Vector3(),
                        rotVel: new THREE.Vector3(),
                        color: new THREE.Color(colors[Math.floor(Math.random() * colors.length)])
                    });
                    this.mesh.setColorAt(i, this.particles[i].color);
                }

                this.mesh.visible = false;
                scene.add(this.mesh);
            }

            start(centerPos) {
                this.active = true;
                this.mesh.visible = true;
                this.particles.forEach((p, i) => {
                    // Spawn area around the winner
                    p.pos.set(
                        centerPos.x + (Math.random() - 0.5) * 40,
                        centerPos.y + 20 + Math.random() * 20,
                        centerPos.z + (Math.random() - 0.5) * 40
                    );
                    p.vel.set(
                        (Math.random() - 0.5) * 0.5,
                        -(Math.random() * 0.2 + 0.1),
                        (Math.random() - 0.5) * 0.5
                    );
                    p.rot.set(Math.random() * Math.PI, Math.random() * Math.PI, Math.random() * Math.PI);
                    p.rotVel.set(Math.random() * 0.2, Math.random() * 0.2, Math.random() * 0.2);

                    this.updateParticle(i, p);
                });
                this.mesh.instanceMatrix.needsUpdate = true;
            }

            stop() {
                this.active = false;
                this.mesh.visible = false;
            }

            updateParticle(i, p) {
                this.dummy.position.copy(p.pos);
                this.dummy.rotation.set(p.rot.x, p.rot.y, p.rot.z);
                this.dummy.updateMatrix();
                this.mesh.setMatrixAt(i, this.dummy.matrix);
            }

            update(delta) {
                if (!this.active) return;

                this.particles.forEach((p, i) => {
                    p.pos.add(p.vel);
                    p.rot.x += p.rotVel.x;
                    p.rot.y += p.rotVel.y;
                    p.rot.z += p.rotVel.z;

                    // Swing effect
                    p.pos.x += Math.sin(Date.now() * 0.001 + i) * 0.02;

                    // Reset if too low
                    if (p.pos.y < 0) {
                        p.pos.y = 40;
                    }

                    this.updateParticle(i, p);
                });
                this.mesh.instanceMatrix.needsUpdate = true;
            }
        }
        const confettiManager = new ConfettiManager(scene);

        // --- é¦¬ã‚¯ãƒ©ã‚¹ ---
        // é¦¬ã®3Dãƒ¢ãƒ‡ãƒ«ã€ç§»å‹•ãƒ­ã‚¸ãƒƒã‚¯ã€ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³ã€ã‚¹ã‚­ãƒ«ç™ºå‹•ã‚’ç®¡ç†
        class Horse {
            constructor(id, data) {
                this.id = id; this.name = data.name; this.skillName = data.skill; this.skillDesc = data.skillDesc; this.icon = data.icon;
                this.checkSkill = data.check; this.applySkill = data.activate; // Store logic
                this.mesh = new THREE.Group();
                this.currentT = 0; this.speed = 0;
                this.baseSpeed = (0.045 + Math.random() * 0.01) * CONFIG.raceSpeedMult;
                this.maxSpeed = this.baseSpeed * 1.5;
                this.stamina = 1.0; this.finished = false; this.finishRank = null;
                this.skillTriggered = false; this.skillActive = false; this.skillTimer = 0;
                this.laneOffset = (id - 2) * CONFIG.laneWidth;
                this.createModel(data.color); scene.add(this.mesh); this.reset();
            }
            // ... (createModel and reset methods remain unchanged, just skipped in this diff for brevity if they are not needing changes, but I need to be careful about line numbers. I will replace the whole block to be safe)

            createAuraTexture() {
                const canvas = document.createElement('canvas');
                canvas.width = 64; canvas.height = 128;
                const ctx = canvas.getContext('2d');

                const gradient = ctx.createLinearGradient(0, 0, 0, 128);
                gradient.addColorStop(0, 'rgba(255, 255, 200, 0)');
                gradient.addColorStop(0.2, 'rgba(255, 220, 100, 0.5)');
                gradient.addColorStop(0.5, 'rgba(255, 200, 0, 0.8)');
                gradient.addColorStop(0.8, 'rgba(255, 150, 0, 0.5)');
                gradient.addColorStop(1, 'rgba(255, 100, 0, 0)');

                ctx.fillStyle = gradient;
                ctx.fillRect(0, 0, 64, 128);

                // Add vertical energy streaks
                ctx.strokeStyle = 'rgba(255, 255, 255, 0.4)';
                ctx.lineWidth = 2;
                for (let i = 0; i < 8; i++) {
                    const x = Math.random() * 64;
                    ctx.beginPath();
                    ctx.moveTo(x, 0);
                    ctx.lineTo(x, 128);
                    ctx.stroke();
                }

                const texture = new THREE.CanvasTexture(canvas);
                return texture;
            }

            createModel(colorHex) {
                this.mat = new THREE.MeshStandardMaterial({ color: colorHex, roughness: 0.4, metalness: 0.1 });
                const maneColor = new THREE.Color(colorHex).multiplyScalar(0.7);
                const maneMat = new THREE.MeshStandardMaterial({ color: maneColor, roughness: 0.9 });
                const noseMat = new THREE.MeshStandardMaterial({ color: 0xffaaaa, roughness: 0.5 });
                const eyeMat = new THREE.MeshBasicMaterial({ color: 0x000000 });
                const hoofMat = new THREE.MeshStandardMaterial({ color: 0x333333, roughness: 0.9 });

                // --- Common Body Structure ---
                const bodyGeo = new THREE.SphereGeometry(0.7, 16, 16);
                bodyGeo.scale(1, 1, 1.5);
                const body = new THREE.Mesh(bodyGeo, this.mat);
                body.position.y = 1.8;
                body.castShadow = true;
                this.body = body;

                // --- Unique Features: Body ---
                if (this.name === "ãƒ›ãƒ¯ã‚¤ãƒˆã‚¦ã‚£ãƒ³ãƒ‰") {
                    // Wings (Angel/Pegasus style)
                    const wingGeo = new THREE.BoxGeometry(0.05, 0.8, 1.2);
                    const wingMat = new THREE.MeshStandardMaterial({ color: 0xEEFFFF, transparent: true, opacity: 0.9, roughness: 0.2 });

                    const wLeft = new THREE.Mesh(wingGeo, wingMat);
                    wLeft.position.set(0.65, 0.4, 0);
                    wLeft.rotation.set(0.5, 0, -0.4);
                    wLeft.castShadow = true;
                    body.add(wLeft);

                    const wRight = new THREE.Mesh(wingGeo, wingMat);
                    wRight.position.set(-0.65, 0.4, 0);
                    wRight.rotation.set(0.5, 0, 0.4);
                    wRight.castShadow = true;
                    body.add(wRight);
                }
                else if (this.name === "ãƒãƒ§ã‚³ãƒãƒƒãƒ—") {
                    // Chocolate Chips
                    const chipGeo = new THREE.SphereGeometry(0.12, 6, 6);
                    const chipMat = new THREE.MeshStandardMaterial({ color: 0x3E2723, roughness: 0.8 });
                    for (let i = 0; i < 12; i++) {
                        const chip = new THREE.Mesh(chipGeo, chipMat);
                        // Random distribution on upper part
                        const u = Math.random();
                        const v = Math.random();
                        const phi = 2 * Math.PI * u;
                        const theta = Math.acos(2 * v - 1);
                        const r = 0.68; // Slightly embedded

                        const x = r * Math.sin(theta) * Math.cos(phi);
                        const y = r * Math.sin(theta) * Math.sin(phi);
                        const z = r * Math.cos(theta); // On sphere checks

                        // We scaled body by (1, 1, 1.5) so distinct scaling needed if strictly adhering, 
                        // but adding to local space of scaled mesh works fine if we just want surface noise.
                        // Bias towards top (y > 0)
                        if (y > -0.2) {
                            chip.position.set(x, y, z * 1.5); // Crude adjust for body scale
                            body.add(chip);
                        }
                    }
                }
                else if (this.name === "ã‚·ãƒ«ãƒãƒ¼ãƒ–ãƒ¬ãƒƒãƒˆ") {
                    // Rocket Boosters
                    const boosterGeo = new THREE.CylinderGeometry(0.15, 0.12, 0.8, 16);
                    const boosterMat = new THREE.MeshStandardMaterial({ color: 0x888888, metalness: 0.8, roughness: 0.3 });

                    const b1 = new THREE.Mesh(boosterGeo, boosterMat);
                    b1.rotation.x = Math.PI / 2;
                    b1.position.set(0.45, 0.2, -0.6);
                    body.add(b1);

                    const b2 = b1.clone();
                    b2.position.set(-0.45, 0.2, -0.6);
                    body.add(b2);

                    // Flame Effect (small static cones for now, could be particles)
                    const flameGeo = new THREE.ConeGeometry(0.08, 0.4, 8);
                    const flameMat = new THREE.MeshBasicMaterial({ color: 0x00FFFF }); // Blue flame
                    const f1 = new THREE.Mesh(flameGeo, flameMat);
                    f1.rotation.x = Math.PI; // Point back
                    f1.position.set(0, -0.6, 0); // Relative to cylinder (rotated cylinder y is local z)
                    b1.add(f1);
                    const f2 = f1.clone();
                    b2.add(f2);
                }

                // --- Neck ---
                const neckGeo = new THREE.CylinderGeometry(0.45, 0.6, 0.8, 16);
                const neck = new THREE.Mesh(neckGeo, this.mat);
                neck.position.set(0, 2.4, 0.8);
                neck.rotation.x = -0.5;
                neck.castShadow = true;

                // --- Head Group ---
                const headGroup = new THREE.Group();
                headGroup.position.set(0, 3.0, 1.2);

                const headGeo = new THREE.SphereGeometry(0.65, 16, 16);
                const headMesh = new THREE.Mesh(headGeo, this.mat);
                headMesh.castShadow = true;
                headGroup.add(headMesh);

                const snoutGeo = new THREE.SphereGeometry(0.35, 16, 16);
                snoutGeo.scale(1, 0.8, 1.2);
                const snout = new THREE.Mesh(snoutGeo, this.mat);
                snout.position.set(0, -0.15, 0.55);
                snout.castShadow = true;
                headGroup.add(snout);

                const earGeo = new THREE.ConeGeometry(0.18, 0.4, 8);
                const earL = new THREE.Mesh(earGeo, this.mat);
                earL.position.set(0.35, 0.55, 0);
                earL.rotation.set(-0.2, 0, -0.3);
                earL.castShadow = true;
                const earR = new THREE.Mesh(earGeo, this.mat);
                earR.position.set(-0.35, 0.55, 0);
                earR.rotation.set(-0.2, 0, 0.3);
                earR.castShadow = true;
                headGroup.add(earL, earR);

                const eyeGeo = new THREE.SphereGeometry(0.09, 8, 8);
                const eyeL = new THREE.Mesh(eyeGeo, eyeMat);
                eyeL.position.set(0.28, 0.1, 0.5);
                const eyeR = new THREE.Mesh(eyeGeo, eyeMat);
                eyeR.position.set(-0.28, 0.1, 0.5);

                // Black Jack Visor replaces eyes visual or covers them
                if (this.name !== "ãƒ–ãƒ©ãƒƒã‚¯ã‚¸ãƒ£ãƒƒã‚¯") {
                    headGroup.add(eyeL, eyeR);
                }

                // Forelock
                const forelockGeo = new THREE.SphereGeometry(0.25, 8, 8);
                const forelock = new THREE.Mesh(forelockGeo, maneMat);
                forelock.position.set(0, 0.55, 0.2);
                headGroup.add(forelock);

                // --- Unique Features: Head ---
                if (this.name === "ãƒ–ãƒ©ãƒƒã‚¯ã‚¸ãƒ£ãƒƒã‚¯") {
                    // Cyber Visor / Sunglasses
                    const visorGeo = new THREE.BoxGeometry(0.7, 0.2, 0.2);
                    const visorMat = new THREE.MeshStandardMaterial({ color: 0x000000, metalness: 0.9, roughness: 0.1 });
                    const visor = new THREE.Mesh(visorGeo, visorMat);
                    visor.position.set(0, 0.15, 0.5);
                    headGroup.add(visor);

                    // Red Sensor Light
                    const sensorGeo = new THREE.BoxGeometry(0.2, 0.05, 0.21);
                    const sensorMat = new THREE.MeshBasicMaterial({ color: 0xFF0000 });
                    const sensor = new THREE.Mesh(sensorGeo, sensorMat);
                    sensor.position.set(0, 0, 0);
                    visor.add(sensor);
                }
                else if (this.name === "ã‚´ãƒ¼ãƒ«ãƒ‡ãƒ³ãƒœãƒ¼ã‚¤") {
                    // Crown
                    const crownGroup = new THREE.Group();
                    crownGroup.position.set(0, 0.7, 0);
                    const cGeo = new THREE.ConeGeometry(0.08, 0.25, 4);
                    const cMat = new THREE.MeshStandardMaterial({ color: 0xFFD700, metalness: 1.0, emissive: 0x222200 });

                    for (let i = 0; i < 5; i++) {
                        const p = new THREE.Mesh(cGeo, cMat);
                        const a = (i / 5) * Math.PI * 2;
                        p.position.set(Math.cos(a) * 0.25, 0, Math.sin(a) * 0.25);
                        p.rotation.x = -0.2; // Flare out
                        p.rotation.y = a;
                        crownGroup.add(p);
                    }
                    headGroup.add(crownGroup);
                }

                // --- Mane ---
                const maneGeo = new THREE.SphereGeometry(0.25, 8, 8);
                const mane1 = new THREE.Mesh(maneGeo, maneMat); mane1.position.set(0, 0.35, -0.35); neck.add(mane1);
                const mane2 = new THREE.Mesh(maneGeo, maneMat); mane2.position.set(0, -0.05, -0.4); neck.add(mane2);
                const mane3 = new THREE.Mesh(maneGeo, maneMat); mane3.position.set(0, -0.45, -0.4); neck.add(mane3);

                // --- Legs ---
                this.legs = [];
                const legGeo = new THREE.CylinderGeometry(0.18, 0.15, 1.0, 8);
                const hoofGeo = new THREE.CylinderGeometry(0.19, 0.22, 0.2, 8);

                [[-0.35, 0.4], [0.35, 0.4], [-0.35, -0.5], [0.35, -0.5]].forEach(p => {
                    const g = new THREE.Group();
                    g.position.set(p[0], 1.2, p[1]);
                    const l = new THREE.Mesh(legGeo, this.mat);
                    l.position.y = -0.5; l.castShadow = true; g.add(l);
                    const h = new THREE.Mesh(hoofGeo, hoofMat);
                    h.position.y = -1.1; h.castShadow = true; g.add(h);
                    this.mesh.add(g);
                    this.legs.push(g);
                });

                // --- Tail ---
                const tailGeo = new THREE.SphereGeometry(0.35, 8, 8);
                tailGeo.scale(1, 1.5, 1);
                const tail = new THREE.Mesh(tailGeo, maneMat);
                tail.position.set(0, 2.2, -0.9);
                tail.rotation.x = 0.6;
                this.tail = tail;

                this.mesh.add(body, neck, headGroup, tail);

                // --- Luxurious Aura Effect (Common) ---
                this.aura = new THREE.Group();
                this.aura.visible = false;
                this.mesh.add(this.aura);

                const pillarGeo = new THREE.CylinderGeometry(1.0, 1.0, 7, 32, 1, true);
                const pillarTex = this.createAuraTexture();
                const pillarMat = new THREE.MeshBasicMaterial({
                    map: pillarTex,
                    color: 0xffdd44,
                    transparent: true,
                    opacity: 0.8,
                    side: THREE.DoubleSide,
                    blending: THREE.AdditiveBlending,
                    depthWrite: false
                });
                this.auraPillar = new THREE.Mesh(pillarGeo, pillarMat);
                this.auraPillar.position.y = 2.5;
                this.aura.add(this.auraPillar);

                const ringGeo = new THREE.TorusGeometry(1.5, 0.05, 8, 64);
                const ringMat = new THREE.MeshBasicMaterial({ color: 0xffaa00, transparent: true, opacity: 0.9, blending: THREE.AdditiveBlending });

                this.auraRing1 = new THREE.Mesh(ringGeo, ringMat);
                this.auraRing1.rotation.x = Math.PI / 2;
                this.auraRing1.position.y = 0.5;
                this.aura.add(this.auraRing1);

                this.auraRing2 = new THREE.Mesh(ringGeo, ringMat);
                this.auraRing2.rotation.x = Math.PI / 2.2;
                this.auraRing2.rotation.y = 0.2;
                this.auraRing2.position.y = 4.0;
                this.auraRing2.scale.setScalar(1.3);
                this.aura.add(this.auraRing2);

                const coreGeo = new THREE.SphereGeometry(0.8, 16, 16);
                const coreMat = new THREE.MeshBasicMaterial({ color: 0xffffee, transparent: true, opacity: 0.6, blending: THREE.AdditiveBlending });
                this.auraCore = new THREE.Mesh(coreGeo, coreMat);
                this.auraCore.position.y = 2.0;
                this.aura.add(this.auraCore);
            }

            reset() {
                this.currentT = CONFIG.startLineT; this.finished = false; this.finishRank = null; this.speed = 0;
                // Race variability: reroll stats per race
                const weatherMultiplier = STATE.weather ? STATE.weather.speedMultiplier : 1.0;
                this.baseSpeed = (0.045 + Math.random() * 0.012) * CONFIG.raceSpeedMult * weatherMultiplier;
                this.maxSpeed = this.baseSpeed * (1.4 + Math.random() * 0.3);

                this.skillTriggered = false; this.skillActive = false; this.skillTimer = 0;
                this.mat.emissive.setHex(0x000000); this.aura.visible = false;

                // Reset Anim
                this.legs.forEach(l => l.rotation.x = 0);
                if (this.body) this.body.position.y = 1.8;
                if (this.tail) this.tail.rotation.x = 0.6;
                this.updatePosition();
            }

            activateSkill() {
                if (this.skillTriggered) return;
                if (STATE.winner) return; // No skills after winner decided
                this.skillTriggered = true; this.skillActive = true; this.skillTimer = 3.0;
                showCutIn(this.name, this.skillName, this.icon);
                SoundManager.playSkill();
                this.mat.emissive.setHex(0xaaaaaa); // Brighter emission

                this.aura.visible = true;
                this.auraRing1.rotation.z = 0;
                this.auraRing2.rotation.z = 0;

                // --- NEW EFFECTS ---
                // 1. Camera Shake
                STATE.cameraShake = 0.5; // Intensity

                // 2. Speed Lines (Only if player horse or close to player)
                // For dramatic effect, show if player horse or if currently viewing this horse
                const isPlayer = (this.id === STATE.selectedHorse);
                if (isPlayer) {
                    const sl = document.getElementById('speed-lines');
                    sl.classList.add('active');
                    setTimeout(() => sl.classList.remove('active'), 1500);
                }

                // 3. Initial Particle Burst
                for (let i = 0; i < 20; i++) {
                    particleManager.spawn(this.mesh.position.clone().add(new THREE.Vector3(0, 2, 0)), ParticleType.SKILL);
                }

                // Execute logical effect from data
                if (this.applySkill) this.applySkill(this);
            }

            updatePosition() {
                const t = this.currentT % 1.0;
                const point = STATE.trackCurve.getPointAt(t);
                const tangent = STATE.trackCurve.getTangentAt(t).normalize();
                const normal = new THREE.Vector3(-tangent.z, 0, tangent.x).normalize();
                const pos = point.add(normal.multiplyScalar(this.laneOffset));
                const backward = tangent.clone().multiplyScalar(-1.5);
                pos.add(backward);
                this.mesh.position.copy(pos); this.mesh.lookAt(pos.clone().add(tangent));
            }

            update(delta) {
                if (this.finished && !STATE.isWinningRun) {
                    this.legs.forEach(l => l.rotation.x = 0);
                    return;
                }

                if (this.speed < this.baseSpeed) this.speed += delta * 0.05;

                const progress = this.currentT;
                if (!this.skillTriggered && this.speed > 0.01) {
                    const r = Math.random();
                    // Use data-driven check
                    if (this.checkSkill && this.checkSkill(progress, r)) {
                        this.activateSkill();
                    }
                }

                if (this.skillActive) {
                    this.skillTimer -= delta;

                    const time = Date.now() * 0.005;
                    // Rotate Rings
                    this.auraRing1.rotation.z += delta * 4;
                    this.auraRing1.scale.setScalar(1.0 + Math.sin(time * 3) * 0.1);

                    this.auraRing2.rotation.z -= delta * 3;
                    this.auraRing2.rotation.x = (Math.PI / 2.2) + Math.sin(time * 2) * 0.1;

                    // Animate Pillar
                    this.auraPillar.rotation.y -= delta * 2;
                    this.auraPillar.scale.set(1.0 + Math.sin(time * 8) * 0.1, 1, 1.0 + Math.sin(time * 8) * 0.1);

                    // Core Pulse
                    this.auraCore.scale.setScalar(0.9 + Math.sin(time * 10) * 0.2);

                    // Float
                    this.aura.position.y = Math.sin(time * 3) * 0.2;

                    if (this.skillTimer <= 0) {
                        this.skillActive = false;
                        this.mat.emissive.setHex(0x000000);
                        this.aura.visible = false;
                    }
                } else {
                    // Random speed fluctuations (simulated jockeying)
                    if (Math.random() < 0.05) this.speed += (Math.random() - 0.5) * 0.001;
                }

                this.currentT += this.speed * delta;
                this.updatePosition();

                if (this.currentT >= 1.0 && !this.finished) {
                    this.finished = true;
                    // Jump pose at finish
                    this.body.position.y = 2.5;
                }

                const runFreq = 20 + (this.speed * 200); const animT = Date.now() * 0.001;

                // Animate Body (Bounce) - Only if not finished
                if (!this.finished) {
                    this.body.position.y = 1.8 + Math.sin(animT * runFreq) * 0.1;
                }

                this.legs[0].rotation.x = Math.sin(animT * runFreq) * 0.8;
                this.legs[1].rotation.x = Math.sin(animT * runFreq + Math.PI) * 0.8;
                this.legs[2].rotation.x = Math.sin(animT * runFreq + Math.PI / 2) * 0.8;
                this.legs[3].rotation.x = Math.sin(animT * runFreq - Math.PI / 2) * 0.8;

                // Tail Animation
                if (this.tail) {
                    this.tail.rotation.x = 0.6 + Math.sin(animT * runFreq * 0.5) * 0.2;
                }

                // Particle Emission
                if (this.skillActive) {
                    if (Math.random() < 0.3) {
                        const emitPos = this.mesh.position.clone();
                        emitPos.y += Math.random() * 3;
                        emitPos.x += (Math.random() - 0.5) * 1.5;
                        emitPos.z += (Math.random() - 0.5) * 1.5;
                        particleManager.spawn(emitPos, ParticleType.SKILL);
                    }
                }

                if (this.speed > 0.02) {
                    const chance = this.speed * 5; // Higher speed = more particles
                    if (Math.random() < chance) {
                        const type = (STATE.weather && STATE.weather.rain) ? ParticleType.SPLASH : ParticleType.DUST;
                        // Emit from base of horse approximate pos
                        const emitPos = this.mesh.position.clone();
                        emitPos.y = 0.5; // Near ground
                        // Add some randomness around the feet area
                        emitPos.x += (Math.random() - 0.5) * 1.0;
                        emitPos.z += (Math.random() - 0.5) * 1.0;
                        particleManager.spawn(emitPos, type);
                    }
                }
            }
        }

        // --- å®Ÿæ³ã‚·ã‚¹ãƒ†ãƒ  ---
        // ãƒ¬ãƒ¼ã‚¹å±•é–‹ã«å¿œã˜ãŸãƒ†ã‚­ã‚¹ãƒˆè¡¨ç¤ºã¨èª­ã¿ä¸Šã’
        let lastCommentTime = 0;
        let lastLeader = null;
        let commentQueue = [];
        const box = document.getElementById('commentary-box');
        const txt = document.getElementById('commentary-text');

        function announce(msg) {
            txt.innerText = msg;
            box.classList.add('active');
            SoundManager.speak(msg); // Read aloud
            setTimeout(() => {
                if (txt.innerText === msg) box.classList.remove('active');
            }, 3000);
        }

        function updateCommentary(time) {
            if (time - lastCommentTime < 3.5) return;
            const sorted = [...STATE.horses].sort((a, b) => b.currentT - a.currentT);
            const leader = sorted[0];
            const second = sorted[1];
            const p = leader.currentT;
            let msg = "";

            if (p < 0.1) {
                // Keep initial start simple to avoid overlap with gate open
            } else if (p > 0.15 && p < 0.2) {
                const phrases = [
                    `å…ˆæ‰‹ã‚’å¥ªã£ãŸã®ã¯ ${leader.name} ã§ã™ï¼`,
                    `${leader.name} ãŒæœæ•¢ã«ãƒãƒŠã‚’ä¸»å¼µã—ã¾ã—ãŸï¼`,
                    `ã¾ãšã¯ ${leader.name} ãŒãƒ¬ãƒ¼ã‚¹ã‚’å¼•ã£å¼µã‚Šã¾ã™ã€‚`
                ];
                msg = phrases[Math.floor(Math.random() * phrases.length)];
            } else if (p > 0.45 && p < 0.5) {
                const phrases = [
                    "ãƒ¬ãƒ¼ã‚¹ã¯ä¸­ç›¤ã€å‘ã“ã†æ­£é¢ã«å…¥ã£ã¦ã„ã¾ã™ï¼",
                    "å„é¦¬ã€æ·¡ã€…ã¨ã—ãŸãƒšãƒ¼ã‚¹ã§é€²ã‚“ã§ã„ã¾ã™ã€‚",
                    `${leader.name}ã€è»½å¿«ãªé€ƒã’ã‚’è¦‹ã›ã¦ã„ã¾ã™ï¼`,
                    "å…ˆé ­ã‹ã‚‰æœ€å¾Œæ–¹ã¾ã§ã€éšŠåˆ—ã¯ç¸¦é•·ã«ãªã£ã¦ã„ã¾ã™ï¼",
                    "ãŠã£ã¨ã€å¾Œæ–¹ã‹ã‚‰ä¸€æ°—ã«é¦¬ç¾¤ãŒå‹•ãå‡ºã—ãŸï¼"
                ];
                msg = phrases[Math.floor(Math.random() * phrases.length)];
            } else if (p > 0.7 && p < 0.75) {
                const phrases = [
                    "ã•ã‚ã€ç¬¬3ã‚³ãƒ¼ãƒŠãƒ¼ã‹ã‚‰ç¬¬4ã‚³ãƒ¼ãƒŠãƒ¼ã¸ï¼",
                    "å‹è² ã©ã“ã‚ï¼å„é¦¬ã‚¹ãƒ‘ãƒ¼ãƒˆã®ä½“å‹¢ã«å…¥ã‚Šã¾ã™ï¼",
                    "å¾Œç¶šã‚‚å·®ã‚’è©°ã‚ã¦ããŸï¼æ··æˆ¦æ¨¡æ§˜ã§ã™ï¼",
                    `${leader.name}ã€æ‰‹å¿œãˆã¯ã©ã†ã‹ï¼ï¼Ÿ`,
                    "4ã‚³ãƒ¼ãƒŠãƒ¼ã‚’å›ã£ã¦ã€ç›´ç·šã‚³ãƒ¼ã‚¹ã¸ï¼"
                ];
                msg = phrases[Math.floor(Math.random() * phrases.length)];
            } else if (p > 0.85 && p < 0.9) {
                const phrases = [
                    "ã•ã‚ã€æœ€å¾Œã®ç›´ç·šï¼ã“ã“ã‹ã‚‰ãŒå‹è² ã ï¼",
                    "ç›´ç·šã‚³ãƒ¼ã‚¹ã«å‘ã„ãŸï¼æŠœã‘å‡ºã™ã®ã¯èª°ã ï¼ï¼Ÿ",
                    "æ®‹ã‚Š200ãƒ¡ãƒ¼ãƒˆãƒ«ï¼æ¿€ã—ã„å©ãåˆã„ï¼",
                    "å¤–ã‹ã‚‰ä¸€æ°—ã«å„é¦¬ãŒè¥²ã„ã‹ã‹ã‚‹ï¼",
                    "å†…ã‹ã‚‰é‹­ãä¼¸ã³ã¦ãã‚‹ã®ã¯ã©ã®é¦¬ã ï¼ï¼Ÿ"
                ];
                msg = phrases[Math.floor(Math.random() * phrases.length)];
            } else {
                if (leader !== lastLeader && p > 0.2) {
                    const phrases = [
                        `${leader.name} ãŒå…ˆé ­ã«ç«‹ã£ãŸï¼`,
                        `ãŠã£ã¨ã€ã“ã“ã§ ${leader.name} ãŒå‡ºãŸï¼`,
                        `${leader.name}ã€ã‹ã‚ã—ãŸï¼å…ˆé ­ãŒå¤‰ã‚ã‚Šã¾ã™ï¼`,
                        `${leader.name}ã€ä¸€æ°—ã«å…ˆé ­ã¸è¸Šã‚Šå‡ºãŸï¼`
                    ];
                    msg = phrases[Math.floor(Math.random() * phrases.length)];
                    lastLeader = leader;
                } else if (Math.random() < 0.2) {
                    const phrases = [
                        `å…ˆé ­ã¯ä¾ç„¶ã¨ã—ã¦ ${leader.name}ï¼`,
                        `${leader.name} ãŒãƒ¬ãƒ¼ã‚¹ã‚’å¼•ã£å¼µã‚Šã¾ã™ï¼`,
                        `2ç•ªæ‰‹ã«ã¯ ${second.name} ãŒã¤ã‘ã¦ã„ã¾ã™ã€‚`,
                        `å„é¦¬ã€ä¸€å›£ã¨ãªã£ã¦é€²ã‚“ã§ã„ã¾ã™ã€‚`,
                        `ãƒšãƒ¼ã‚¹ãŒä¸ŠãŒã£ã¦ãã¾ã—ãŸï¼`,
                        `${second.name}ã€è™è¦–çœˆã€…ã¨ãƒãƒ£ãƒ³ã‚¹ã‚’ä¼ºã£ã¦ã„ã¾ã™ï¼`,
                        `ã¾ã å„é¦¬ã€å‹•ãã¯ã‚ã‚Šã¾ã›ã‚“ã€‚`
                    ];
                    msg = phrases[Math.floor(Math.random() * phrases.length)];
                }
            }
            if (msg) { announce(msg); lastCommentTime = time; }
        }

        // --- UI & ã‚²ãƒ¼ãƒ é€²è¡Œãƒ­ã‚¸ãƒƒã‚¯ ---
        // ã‚«ãƒƒãƒˆã‚¤ãƒ³è¡¨ç¤ºã€ã‚¹ã‚¿ãƒ¼ãƒˆå‡¦ç†ã€å‹è€…åˆ¤å®šãªã©
        function showCutIn(name, skill, icon) {
            const el = document.getElementById('cut-in-overlay');
            document.getElementById('cut-in-name').innerText = name;
            document.getElementById('cut-in-skill').innerText = skill;
            document.getElementById('cut-in-horse').innerText = icon;
            el.classList.remove('active'); void el.offsetWidth; el.classList.add('active');
            setTimeout(() => el.classList.remove('active'), 1500);
        }

        function announceWinner(winner) {
            const winPhrases = [
                `ï¼‘ç€ã€${winner.name}ï¼ è¦‹äº‹ãªå‹åˆ©ã§ã™ï¼`,
                `å‹ã£ãŸã®ã¯ ${winner.name}ï¼ åœ§å€’çš„ãªå¼·ã•ã‚’è¦‹ã›ã¤ã‘ã¾ã—ãŸï¼`,
                `${winner.name}ã€ã‚´ãƒ¼ãƒ«ã‚¤ãƒ³ï¼ ç´ æ™´ã‚‰ã—ã„èµ°ã‚Šã§ã—ãŸï¼`,
                `å¤§æ­“å£°ã®ä¸­ã€${winner.name} ãŒå…ˆé ­ã§ã‚´ãƒ¼ãƒ«ã‚’é§†ã‘æŠœã‘ã¾ã—ãŸï¼`
            ];
            const msg = winPhrases[Math.floor(Math.random() * winPhrases.length)];
            announce(msg);
            STATE.winnerAnnounced = true;
        }

        function initGame() {
            document.getElementById('progress-bar').style.width = '80%';

            // 1. Build Track first (Needed for Horse positioning logic)
            selectRandomCourse();

            // 2. Create Horses
            HORSE_DATA.forEach((data, index) => {
                const h = new Horse(index, data); STATE.horses.push(h);
                // 3. Create Gates (since buildTrack skipped them as horses array was empty)
                const gate = new Gate((index - 2) * CONFIG.laneWidth);
                STATE.gates.push(gate);
            });



            const selector = document.getElementById('horse-selector');
            HORSE_DATA.forEach((data, index) => {
                const el = document.createElement('div');
                el.className = 'horse-card p-2 pb-8 cursor-pointer flex flex-col items-center relative overflow-hidden';
                el.innerHTML = `<div class="horse-badge">x${(Math.random() * 2 + 1.5).toFixed(1)}</div><div class="w-10 h-10 rounded-full mb-1 border-2 border-white/20 text-xl flex items-center justify-center shadow-inner" style="background:#${data.color.toString(16)}">${data.icon}</div><div class="text-xs font-bold text-gray-200 leading-tight text-center font-tech tracking-wide mb-1">${data.name}</div><div class="skill-badge w-full">${data.skill}</div>`;
                el.dataset.odds = el.querySelector('.horse-badge').innerText.replace('x', '');
                el.onclick = () => selectHorse(index, el);
                selector.appendChild(el);
            });
            setTimeout(() => {
                document.getElementById('loader').style.opacity = 0;
                setTimeout(() => document.getElementById('loader').remove(), 500);
            }, 1000);
            updateCamera(0);
        }

        function selectHorse(index, el) {
            SoundManager.init(); // Initialize audio context on first click
            SoundManager.playClick();
            if (STATE.isRacing) return;
            STATE.selectedHorse = index;
            document.querySelectorAll('.horse-card').forEach(c => c.classList.remove('selected'));
            el.classList.add('selected');
            const btn = document.getElementById('start-btn');
            btn.disabled = false;
            // Remove disabled styling
            btn.classList.remove('cursor-not-allowed', 'opacity-50');
            btn.classList.add('cursor-pointer', 'opacity-100');

            btn.innerHTML = '<span class="block skew-x-[15deg] tracking-[0.2em]">START RACE!</span>';
        }

        function startRace() {
            if (STATE.wallet < STATE.betAmount) { alert("No money!"); return; }
            STATE.wallet -= STATE.betAmount; document.getElementById('wallet-display').innerText = STATE.wallet;
            STATE.isRacing = true; STATE.raceStarted = false;

            // Set random weather for this race
            const randomWeather = WEATHER_TYPES[Math.floor(Math.random() * WEATHER_TYPES.length)];
            applyWeather(randomWeather);

            const bettingPanel = document.getElementById('betting-panel');
            bettingPanel.classList.add('opacity-0', 'pointer-events-none');
            bettingPanel.querySelector('.glass-panel').classList.add('scale-95');

            document.getElementById('camera-btn').classList.remove('hidden');
            document.getElementById('rank-panel').classList.remove('hidden');
            STATE.horses.forEach(h => { h.reset(); h.speed = 0; });
            STATE.gates.forEach(g => g.reset());
            STATE.winnerAnnounced = false; // Reset winner announcement flag
            STATE.cameraMode = 3; updateCamera(0); // Auto Camera Start

            SoundManager.playFanfare();
            announce(`${randomWeather.icon} ${randomWeather.name}ã€é¦¬å ´çŠ¶æ…‹: ${randomWeather.trackCondition}`);

            const cdOverlay = document.getElementById('countdown-overlay');
            const cdText = document.getElementById('countdown-text');
            cdOverlay.classList.remove('hidden'); cdText.style.opacity = "1";
            let count = 3;

            // Wait for Fanfare (roughly 3s) then start countdown
            setTimeout(() => {
                cdText.innerText = count;
                cdText.className = "text-9xl font-black text-white drop-shadow-lg scale-in";
                SoundManager.playCountdown(3);

                const interval = setInterval(() => {
                    count--;
                    if (count > 0) {
                        cdText.innerText = count; cdText.classList.remove('scale-in'); void cdText.offsetWidth; cdText.classList.add('scale-in');
                        SoundManager.playCountdown(count);
                    } else if (count === 0) {
                        cdText.innerText = "GO!"; cdText.classList.remove('text-white'); cdText.classList.add('text-yellow-400', 'scale-in');
                        SoundManager.playCountdown(0); // GO sound
                        SoundManager.playGate();
                        SoundManager.playAtmosphere(true); // Start crowd/run noise

                        STATE.gates.forEach(g => g.open());
                        announce("ã‚²ãƒ¼ãƒˆãŒé–‹ã„ãŸï¼");
                        setTimeout(() => {
                            STATE.raceStarted = true;
                            STATE.horses.forEach(h => { h.speed = h.baseSpeed * 0.3; });
                        }, 200);
                    } else {
                        clearInterval(interval); cdText.style.opacity = "0";
                        setTimeout(() => { cdOverlay.classList.add('hidden'); cdText.innerText = ""; cdText.style.opacity = "1"; }, 500);
                    }
                }, 1000);
            }, 2500);
        }

        function finishRace(winner) {
            STATE.isRacing = false; STATE.raceStarted = false; STATE.isWinningRun = true;
            const win = (winner.id === STATE.selectedHorse);
            document.getElementById('rank-panel').classList.add('hidden');

            // Winning Run Setup
            confettiManager.start(winner.mesh.position);
            updateCamera(0); // Trigger camera update to switch to winning mode immediately

            if (win) SoundManager.playWin();

            setTimeout(() => {
                const modal = document.getElementById('result-modal'); modal.classList.remove('hidden', 'scale-95', 'opacity-0');
                const msg = document.getElementById('result-message'); const pay = document.getElementById('payout-display');
                if (win) {
                    const cards = document.querySelectorAll('.horse-card'); const odds = parseFloat(cards[STATE.selectedHorse].dataset.odds);
                    const prize = Math.floor(STATE.betAmount * odds); STATE.wallet += prize;
                    msg.innerHTML = `<span class="text-green-600 font-bold">${winner.name}</span> WON!`; pay.innerText = `+${prize} G`;
                    document.getElementById('wallet-display').innerText = STATE.wallet;
                } else {
                    msg.innerHTML = `Winner: <span class="text-gray-800 font-bold">${winner.name}</span>`; pay.innerText = "0 G";
                }
            }, 3000);
        }

        function resetGame() {
            STATE.isWinningRun = false;
            STATE.winner = null;
            confettiManager.stop();
            document.getElementById('result-modal').classList.add('hidden', 'scale-95', 'opacity-0');

            const bettingPanel = document.getElementById('betting-panel');
            bettingPanel.classList.remove('opacity-0', 'pointer-events-none');
            bettingPanel.querySelector('.glass-panel').classList.remove('scale-95');

            document.getElementById('camera-btn').classList.add('hidden');

            // Random Course for next race
            selectRandomCourse();

            STATE.horses.forEach(h => h.reset());
            // Gates are reset inside buildTrack (technically recreated)
            // But if we want to be safe:
            // STATE.gates.forEach(g => g.reset()); // They are new, so already closed.

            updateCamera(0);
            document.getElementById('commentary-box').classList.remove('active');
            SoundManager.playAtmosphere(false);
        }

        function toggleCamera() {
            STATE.cameraMode = (STATE.cameraMode + 1) % 4;
            const btn = document.getElementById('camera-btn');
            const icons = ["ğŸ“·", "ğŸš", "â†”", "ğŸ“º"];
            btn.innerText = icons[STATE.cameraMode];
        }

        function updateRankingUI() {
            // Sort: Finished horses by rank, then running horses by position
            const sorted = [...STATE.horses].sort((a, b) => {
                if (a.finished && b.finished) return a.finishRank - b.finishRank;
                if (a.finished) return -1;
                if (b.finished) return 1;
                return b.currentT - a.currentT;
            });
            const list = document.getElementById('rank-list'); list.innerHTML = "";
            sorted.forEach((h, i) => {
                const li = document.createElement('li'); li.className = "flex items-center justify-between p-1 rounded bg-white/10";
                const isPlayer = (h.id === STATE.selectedHorse); if (isPlayer) li.classList.add("border", "border-yellow-500/50");
                const rankDisplay = h.finished ? h.finishRank : i + 1;
                const rankClass = h.finished ? 'text-green-400' : (i === 0 ? 'text-yellow-400' : 'text-gray-400');
                li.innerHTML = `<div class="flex items-center gap-2"><span class="w-4 text-center font-bold ${rankClass}">${rankDisplay}</span><div class="w-4 h-4 rounded-full flex items-center justify-center text-[8px]" style="background:#${h.mat.color.getHexString()}">${h.icon}</div><span class="text-xs truncate w-24 ${isPlayer ? 'text-yellow-200' : 'text-gray-300'}">${h.name}</span></div>${h.finished ? '<span class="text-[10px] text-green-400">âœ“</span>' : ''}`;
                list.appendChild(li);
            });
        }

        let lastRankUpdate = 0;

        const clock = new THREE.Clock();
        function updateCamera(time) {
            let leader = STATE.horses[0]; STATE.horses.forEach(h => { if (h.currentT > leader.currentT) leader = h; });
            const leadPos = leader.mesh.position.clone();

            if (STATE.isWinningRun && STATE.winner) {
                // Winning Run Camera - dynamic orbit around winner
                const winner = STATE.winner;
                const leadPos = winner.mesh.position.clone();
                const t = Date.now() * 0.0005;
                const orbitRadius = 15;
                const camX = leadPos.x + Math.cos(t) * orbitRadius;
                const camZ = leadPos.z + Math.sin(t) * orbitRadius;

                camera.position.lerp(new THREE.Vector3(camX, leadPos.y + 5, camZ), 0.05);
                camera.lookAt(leadPos.clone().add(new THREE.Vector3(0, 2, 0)));
            }
            else if (!STATE.isRacing) {
                // Animated camera tour around the track during horse selection
                const t = (Date.now() * 0.00008) % 1.0; // Very slow rotation for elegant presentation
                const tourPoint = STATE.trackCurve.getPointAt(t);
                const tangent = STATE.trackCurve.getTangentAt(t).normalize();
                const normal = new THREE.Vector3(-tangent.z, 0, tangent.x).normalize();

                // Position camera outside the track, looking inward
                const camPos = tourPoint.clone()
                    .add(normal.multiplyScalar(-80)) // Outside the track
                    .add(new THREE.Vector3(0, 60, 0)); // Elevated view

                const lookAt = tourPoint.clone().add(new THREE.Vector3(0, 5, 0));
                camera.position.copy(camPos);
                camera.lookAt(lookAt);
            }
            else {
                // Race Camera Modes
                const t = leader.currentT % 1.0;
                const tan = STATE.trackCurve.getTangentAt(t).normalize();
                const normal = new THREE.Vector3(-tan.z, 0, tan.x).normalize();

                if (STATE.cameraMode === 3) {
                    // --- TVä¸­ç¶™é¢¨ ã‚ªãƒ¼ãƒˆã‚«ãƒ¡ãƒ©ãƒ­ã‚¸ãƒƒã‚¯ ---
                    // å¤šå½©ãªã‚«ãƒ¡ãƒ©ã‚¢ãƒ³ã‚°ãƒ«ã‚’ãƒ©ãƒ³ãƒ€ãƒ ã¾ãŸã¯çŠ¶æ³ã«å¿œã˜ã¦åˆ‡ã‚Šæ›¿ãˆ
                    const p = leader.currentT;

                    // Auto Switching Logic (more frequent, random)
                    if (time - STATE.lastAutoSwitch > 2.5) {
                        let nextType;
                        do {
                            nextType = Math.floor(Math.random() * 4);
                        } while (nextType === STATE.autoShotType); // Avoid same shot twice
                        STATE.autoShotType = nextType;
                        STATE.lastAutoSwitch = time;
                    }

                    let targetPos, targetLook;
                    const lerpFactor = 0.05;

                    if (p < 0.1) {
                        // Start: High Rear Wide Shot
                        targetPos = leadPos.clone().sub(tan.multiplyScalar(25)).add(new THREE.Vector3(0, 15, 0));
                        targetLook = leadPos.clone().add(tan.multiplyScalar(20));
                    } else if (p > 0.85) {
                        // Final Stretch: Dynamic Front Zoom
                        targetPos = leadPos.clone().add(tan.multiplyScalar(20)).sub(normal.multiplyScalar(5)).add(new THREE.Vector3(0, 4, 0));
                        targetLook = leadPos.clone().sub(new THREE.Vector3(0, 1, 0));
                    } else {
                        // Mid Race Switching
                        switch (STATE.autoShotType) {
                            case 0: // Dynamic Side-Front
                                targetPos = leadPos.clone().add(normal.multiplyScalar(12)).add(tan.multiplyScalar(8)).add(new THREE.Vector3(0, 6, 0));
                                targetLook = leadPos.clone();
                                break;
                            case 1: // Low Rear Tracking
                                targetPos = leadPos.clone().sub(tan.multiplyScalar(10)).add(new THREE.Vector3(0, 2, 0));
                                targetLook = leadPos.clone().add(new THREE.Vector3(0, 1, 0));
                                break;
                            case 2: // High Bird's Eye
                                targetPos = leadPos.clone().sub(tan.multiplyScalar(5)).add(new THREE.Vector3(0, 50, 0));
                                targetLook = leadPos.clone();
                                break;
                            case 3: // Side Profile Long
                                const sideDist = 25;
                                targetPos = leadPos.clone().add(normal.multiplyScalar(sideDist)).add(new THREE.Vector3(0, 10, 0));
                                targetLook = leadPos.clone();
                                break;
                        }
                    }
                    camera.position.lerp(targetPos, lerpFactor);
                    camera.lookAt(targetLook);

                    // --- CAMERA SHAKE ---
                    if (STATE.cameraShake > 0) {
                        const shakeAmount = STATE.cameraShake;
                        camera.position.x += (Math.random() - 0.5) * shakeAmount;
                        camera.position.y += (Math.random() - 0.5) * shakeAmount;
                        camera.position.z += (Math.random() - 0.5) * shakeAmount;
                        STATE.cameraShake *= 0.9; // Decay
                        if (STATE.cameraShake < 0.01) STATE.cameraShake = 0;
                    }

                } else if (STATE.cameraMode === 0) {
                    // Follow camera
                    const camPos = leadPos.clone().sub(tan.multiplyScalar(40)).add(new THREE.Vector3(0, 25, 0));
                    camera.position.lerp(camPos, 0.1);
                    camera.lookAt(leadPos.clone().add(tan.multiplyScalar(20)));
                } else if (STATE.cameraMode === 1) {
                    // Top camera
                    camera.position.lerp(new THREE.Vector3(0, 120, 120), 0.05);
                    camera.lookAt(leadPos);
                } else {
                    // Side camera
                    const side = new THREE.Vector3(-tan.z, 0, tan.x).normalize().multiplyScalar(10);
                    camera.position.copy(leadPos.clone().add(side).add(new THREE.Vector3(0, 5, 0)));
                    camera.lookAt(leadPos);
                }
            }
        }

        // Initialize Spectators
        // spectatorManager = new SpectatorManager(scene); // Removed redundant init

        // --- ãƒ¡ã‚¤ãƒ³ãƒ«ãƒ¼ãƒ— ---
        // æ¯ãƒ•ãƒ¬ãƒ¼ãƒ ã®æ›´æ–°å‡¦ç† (ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³ã€ç‰©ç†æ¼”ç®—ã€æç”»)
        function animate() {
            requestAnimationFrame(animate);
            const deltaRaw = clock.getDelta();
            const now = clock.getElapsedTime();

            // --- Time Scale Logic (Photo Finish) ---
            let targetTimeScale = 1.0;
            const leader = STATE.horses.length > 0 ? STATE.horses.reduce((prev, current) => (prev.currentT > current.currentT) ? prev : current) : null;

            if (STATE.isRacing && !STATE.winner && leader) {
                // Slow motion if leader is very close to finish (0.96 to 1.0)
                if (leader.currentT > 0.96 && leader.currentT < 1.0) {
                    targetTimeScale = 0.2; // Slow Motion!
                }
            } else if (STATE.winner) {
                // Restore speed after finish
                targetTimeScale = 1.0;
            }

            // Smooth transition for time scale
            STATE.timeScale += (targetTimeScale - STATE.timeScale) * 0.1;

            // Cap delta to prevent huge jumps if tab was inactive, and apply timeScale
            const delta = Math.min(deltaRaw, 0.1) * STATE.timeScale;

            STATE.gates.forEach(g => g.update(delta));

            // Update Visuals (Pass raw delta or scaled? Spectators might want reliable frames, but slow motion is cool too)
            // Let's make spectators slow down too for consistency
            if (spectatorManager) {
                const leaderP = leader ? leader.currentT : 0;
                spectatorManager.update(now, leaderP);
            }

            if (STATE.isWinningRun && STATE.winner) {
                // Slow forward movement for winner
                const winner = STATE.winner;
                winner.speed = 0.01; // Slow trot
                winner.update(delta); // Animation

                // Keep other horses idle
                STATE.horses.forEach(h => {
                    if (h !== winner) {
                        h.body.position.y = 2 + Math.sin(Date.now() * 0.003 + h.id) * 0.05;
                        h.legs.forEach(l => l.rotation.x = 0); // Ensure others stop running
                    }
                });

                confettiManager.update(delta);
                particleManager.update(delta); // Keep existing particles alive/fading
                updateCamera(now);
                renderer.render(scene, camera);
                return;
            }

            if (STATE.isRacing) {
                particleManager.update(delta); // Update particles
                if (STATE.raceStarted) {
                    let finishedCount = 0;
                    STATE.horses.forEach(h => {
                        if (!h.finished) {
                            h.update(delta);
                            if (h.finished) {
                                // Assign finish rank
                                const finishedHorses = STATE.horses.filter(horse => horse.finished);
                                h.finishRank = finishedHorses.length;
                                if (!STATE.winner) {
                                    STATE.winner = h;
                                    if (!STATE.winnerAnnounced) announceWinner(h);
                                }
                            }
                        } else {
                            finishedCount++;
                        }
                    });
                    if (!STATE.winner) updateCommentary(now);
                    if (now - lastRankUpdate > 0.5) {
                        updateRankingUI();
                        lastRankUpdate = now;
                    }
                    if (STATE.winner && STATE.isRacing && finishedCount === STATE.horses.length) { finishRace(STATE.winner); }
                } else {
                    STATE.horses.forEach(h => { h.body.position.y = 2 + Math.sin(Date.now() * 0.005 + h.id) * 0.02; });
                }
            } else {
                STATE.horses.forEach(h => { h.body.position.y = 2 + Math.sin(Date.now() * 0.003 + h.id) * 0.05; });
            }

            // Animate rain particles
            if (STATE.rainParticles) {
                const positions = STATE.rainParticles.geometry.attributes.position.array;
                for (let i = 0; i < positions.length; i += 3) {
                    positions[i + 1] -= (2 * STATE.timeScale); // Fall down adjusted by timeScale
                    if (positions[i + 1] < 0) {
                        positions[i + 1] = 200; // Reset to top
                    }
                }
                STATE.rainParticles.geometry.attributes.position.needsUpdate = true;
            }

            updateCamera(now); renderer.render(scene, camera);
        }

        initGame(); animate();
        window.addEventListener('resize', () => { camera.aspect = window.innerWidth / window.innerHeight; camera.updateProjectionMatrix(); renderer.setSize(window.innerWidth, window.innerHeight); });
    </script>
</body>

</html>
